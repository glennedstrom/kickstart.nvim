{
  "Fenwick Tree (Binary Indexed Tree)": {
    "prefix": "fenwick",
    "body": [
      "#define LSOne(S) ((S) & -(S))",
      "",
      "typedef long long ll;",
      "typedef vector<ll> vll;",
      "",
      "class FenwickTree {",
      "private:",
      "  vll ft;",
      "public:",
      "  FenwickTree(int m) { ft.assign(m+1, 0); }",
      "",
      "  void build(const vll &f) {",
      "    int m = (int)f.size()-1;",
      "    ft.assign(m+1, 0);",
      "    for (int i = 1; i <= m; ++i) {",
      "      ft[i] += f[i];",
      "      if (i+LSOne(i) <= m)",
      "        ft[i+LSOne(i)] += ft[i];",
      "    }",
      "  }",
      "",
      "  FenwickTree(const vll &f) { build(f); }",
      "",
      "  ll rsq(int j) {",
      "    ll sum = 0;",
      "    for (; j; j -= LSOne(j))",
      "      sum += ft[j];",
      "    return sum;",
      "  }",
      "",
      "  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); }",
      "",
      "  void update(int i, ll v) {",
      "    for (; i < (int)ft.size(); i += LSOne(i))",
      "      ft[i] += v;",
      "  }",
      "",
      "  int select(ll k) {",
      "    int p = 1;",
      "    while (p*2 < (int)ft.size()) p *= 2;",
      "    int i = 0;",
      "    while (p) {",
      "      if (k > ft[i+p]) {",
      "        k -= ft[i+p];",
      "        i += p;",
      "      }",
      "      p /= 2;",
      "    }",
      "    return i+1;",
      "  }",
      "};"
    ],
    "description": "Fenwick Tree (Binary Indexed Tree) for range sum queries and updates",
    "scope": "cpp"
  },

  "RUPQ Fenwick Tree": {
    "prefix": "fenwick_rupq",
    "body": [
      "class RUPQ {",
      "private:",
      "  FenwickTree ft;",
      "public:",
      "  RUPQ(int m) : ft(FenwickTree(m)) {}",
      "  void range_update(int ui, int uj, ll v) {",
      "    ft.update(ui, v);",
      "    ft.update(uj+1, -v);",
      "  }",
      "  ll point_query(int i) { return ft.rsq(i); }",
      "};"
    ],
    "description": "Range Update Point Query Fenwick Tree",
    "scope": "cpp"
  },

  "RURQ Fenwick Tree": {
    "prefix": "fenwick_rurq",
    "body": [
      "class RURQ {",
      "private:",
      "  RUPQ rupq;",
      "  FenwickTree purq;",
      "public:",
      "  RURQ(int m) : rupq(RUPQ(m)), purq(FenwickTree(m)) {}",
      "  void range_update(int ui, int uj, ll v) {",
      "    rupq.range_update(ui, uj, v);",
      "    purq.update(ui, v*(ui-1));",
      "    purq.update(uj+1, -v*uj);",
      "  }",
      "  ll rsq(int j) {",
      "    return rupq.point_query(j)*j - purq.rsq(j);",
      "  }",
      "  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); }",
      "};"
    ],
    "description": "Range Update Range Query Fenwick Tree",
    "scope": "cpp"
  },

  "Segment Tree": {
    "prefix": "segtree",
    "body": [
      "typedef vector<int> vi;",
      "",
      "class SegmentTree {",
      "private:",
      "  int n;",
      "  vi A, st, lazy;",
      "",
      "  int l(int p) { return p<<1; }",
      "  int r(int p) { return (p<<1)+1; }",
      "",
      "  int conquer(int a, int b) {",
      "    if (a == -1) return b;",
      "    if (b == -1) return a;",
      "    return min(a, b); // Change this for different operations",
      "  }",
      "",
      "  void build(int p, int L, int R) {",
      "    if (L == R)",
      "      st[p] = A[L];",
      "    else {",
      "      int m = (L+R)/2;",
      "      build(l(p), L, m);",
      "      build(r(p), m+1, R);",
      "      st[p] = conquer(st[l(p)], st[r(p)]);",
      "    }",
      "  }",
      "",
      "  void propagate(int p, int L, int R) {",
      "    if (lazy[p] != -1) {",
      "      st[p] = lazy[p];",
      "      if (L != R)",
      "        lazy[l(p)] = lazy[r(p)] = lazy[p];",
      "      else",
      "        A[L] = lazy[p];",
      "      lazy[p] = -1;",
      "    }",
      "  }",
      "",
      "  int RMQ(int p, int L, int R, int i, int j) {",
      "    propagate(p, L, R);",
      "    if (i > j) return -1;",
      "    if ((L >= i) && (R <= j)) return st[p];",
      "    int m = (L+R)/2;",
      "    return conquer(RMQ(l(p), L, m, i, min(m, j)),",
      "                   RMQ(r(p), m+1, R, max(i, m+1), j));",
      "  }",
      "",
      "  void update(int p, int L, int R, int i, int j, int val) {",
      "    propagate(p, L, R);",
      "    if (i > j) return;",
      "    if ((L >= i) && (R <= j)) {",
      "      lazy[p] = val;",
      "      propagate(p, L, R);",
      "    }",
      "    else {",
      "      int m = (L+R)/2;",
      "      update(l(p), L, m, i, min(m, j), val);",
      "      update(r(p), m+1, R, max(i, m+1), j, val);",
      "      int lsubtree = (lazy[l(p)] != -1) ? lazy[l(p)] : st[l(p)];",
      "      int rsubtree = (lazy[r(p)] != -1) ? lazy[r(p)] : st[r(p)];",
      "      st[p] = conquer(lsubtree, rsubtree);",
      "    }",
      "  }",
      "",
      "public:",
      "  SegmentTree(int sz) : n(sz), A(n), st(4*n), lazy(4*n, -1) {}",
      "",
      "  SegmentTree(const vi &initialA) : SegmentTree((int)initialA.size()) {",
      "    A = initialA;",
      "    build(1, 0, n-1);",
      "  }",
      "",
      "  void update(int i, int j, int val) { update(1, 0, n-1, i, j, val); }",
      "  int RMQ(int i, int j) { return RMQ(1, 0, n-1, i, j); }",
      "};"
    ],
    "description": "Segment Tree with lazy propagation for range queries and updates",
    "scope": "cpp"
  },

  "Union-Find (Disjoint Set Union)": {
    "prefix": "unionfind",
    "body": [
      "class UnionFind{",
      "private:",
      "    vector<int> _parent, _rank, _setSize;",
      "    int _numSets;",
      "public:",
      "    UnionFind(int n) : _parent(vector<int>(n)), _rank(vector<int>(n,1)), _setSize(vector<int>(n,1)), _numSets(n){ iota(_parent.begin(), _parent.end(), 0); }",
      "",
      "    int size(){ return _parent.size(); }",
      "    int setSize(int n){return _setSize[findSet(n)];}",
      "    int numSets(){ return _numSets; }",
      "    bool isSameSet(int u,int v){ return findSet(u) == findSet(v); }",
      "",
      "    int findSet(int n){ return _parent.at(n) == n ? n : _parent[n] = findSet(_parent[n]); }",
      "",
      "    void unionSet(int u, int v){",
      "        u = findSet(u); v = findSet(v);",
      "        if(u == v) return;",
      "",
      "        if(_rank[u] < _rank[v]) swap(u,v);",
      "        _parent[v] = u;",
      "",
      "        if(_rank[u] == _rank[v]) _rank[u]++;",
      "        _setSize[u] += _setSize[v];",
      "        _numSets--;",
      "    }",
      "};"
    ],
    "description": "Union-Find (Disjoint Set Union) with path compression and union by rank",
    "scope": "cpp"
  },

  "Graph Adjacency List": {
    "prefix": "graphal",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<ii> vii;",
      "",
      "int V, E;",
      "vector<vii> AL;",
      "",
      "// Initialize: AL.assign(V, vii());",
      "// Add edge: AL[u].emplace_back(v, w);"
    ],
    "description": "Graph representation using Adjacency List",
    "scope": "cpp"
  },

  "Graph Edge List": {
    "prefix": "graphel",
    "body": [
      "typedef tuple<int, int, int> iii;",
      "",
      "int E;",
      "vector<iii> EL;",
      "",
      "// Add edge: EL.emplace_back(w, u, v);",
      "// Sort by weight: sort(EL.begin(), EL.end());"
    ],
    "description": "Graph representation using Edge List",
    "scope": "cpp"
  },

  "Graph Adjacency Matrix": {
    "prefix": "grapham",
    "body": [
      "const int MAX_V = ${1:1010};",
      "",
      "int AM[MAX_V][MAX_V];",
      "",
      "// Initialize all to 0 or INF",
      "// Set edge: AM[u][v] = weight;"
    ],
    "description": "Graph representation using Adjacency Matrix",
    "scope": "cpp"
  },

  "Competitive Programming Template": {
    "prefix": "cptemplate",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "typedef long long ll;",
      "typedef vector<int> vi;",
      "typedef vector<ll> vll;",
      "typedef pair<int, int> ii;",
      "typedef vector<ii> vii;",
      "",
      "#define LSOne(S) ((S) & -(S))",
      "#define EPS 1e-9",
      "#define INF 1e9",
      "",
      "int main() {",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    ",
      "    ${1:// Your code here}",
      "    ",
      "    return 0;",
      "}"
    ],
    "description": "Basic competitive programming template with common includes and typedefs",
    "scope": "cpp"
  },

  "Fast I/O Template": {
    "prefix": "fastio",
    "body": [
      "ios_base::sync_with_stdio(false);",
      "cin.tie(NULL);",
      "cout.tie(NULL);"
    ],
    "description": "Fast I/O for competitive programming",
    "scope": "cpp"
  }
}
