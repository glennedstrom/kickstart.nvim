{
  "Floyd Warshall APSP": {
    "prefix": "floyd",
    "body": [
      "const int INF = 1e9;",
      "const int MAX_V = 450;",
      "",
      "int AM[MAX_V][MAX_V];",
      "",
      "void floydWarshall(int V) {",
      "  for (int u = 0; u < V; ++u) {",
      "    for (int v = 0; v < V; ++v)",
      "      AM[u][v] = INF;",
      "    AM[u][u] = 0;",
      "  }",
      "  ",
      "  // Read edges: AM[u][v] = w;",
      "  ",
      "  for (int k = 0; k < V; ++k)",
      "    for (int u = 0; u < V; ++u)",
      "      for (int v = 0; v < V; ++v)",
      "        AM[u][v] = min(AM[u][v], AM[u][k]+AM[k][v]);",
      "}"
    ],
    "description": "Floyd Warshall algorithm for All Pairs Shortest Path (O(V^3))",
    "scope": "cpp"
  },

  "Hierholzer Eulerian Path": {
    "prefix": "hierholzer",
    "body": [
      "typedef vector<int> vi;",
      "",
      "int N;",
      "vector<vi> AL;",
      "",
      "vi hierholzer(int s) {",
      "  vi ans, idx(N, 0), st;",
      "  st.push_back(s);",
      "  while (!st.empty()) {",
      "    int u = st.back();",
      "    if (idx[u] < (int)AL[u].size()) {",
      "      st.push_back(AL[u][idx[u]]);",
      "      ++idx[u];",
      "    }",
      "    else {",
      "      ans.push_back(u);",
      "      st.pop_back();",
      "    }",
      "  }",
      "  reverse(ans.begin(), ans.end());",
      "  return ans;",
      "}"
    ],
    "description": "Hierholzer's algorithm for finding Eulerian path/cycle",
    "scope": "cpp"
  },

  "Bellman Ford SSSP": {
    "prefix": "bellmanford",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<int> vi;",
      "typedef vector<ii> vii;",
      "",
      "const int INF = 1e9;",
      "",
      "pair<vi, bool> bellmanFord(int V, vector<vii>& AL, int s) {",
      "  vi dist(V, INF); dist[s] = 0;",
      "  for (int i = 0; i < V-1; ++i) {",
      "    bool modified = false;",
      "    for (int u = 0; u < V; ++u)",
      "      if (dist[u] != INF)",
      "        for (auto &[v, w] : AL[u]) {",
      "          if (dist[u]+w >= dist[v]) continue;",
      "          dist[v] = dist[u]+w;",
      "          modified = true;",
      "        }",
      "    if (!modified) break;",
      "  }",
      "  ",
      "  bool hasNegativeCycle = false;",
      "  for (int u = 0; u < V; ++u)",
      "    if (dist[u] != INF)",
      "      for (auto &[v, w] : AL[u])",
      "        if (dist[v] > dist[u]+w)",
      "          hasNegativeCycle = true;",
      "  ",
      "  return {dist, hasNegativeCycle};",
      "}"
    ],
    "description": "Bellman Ford algorithm for SSSP with negative edge detection (O(VE))",
    "scope": "cpp"
  },

  "SPFA (Bellman Ford Moore)": {
    "prefix": "spfa",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<int> vi;",
      "typedef vector<ii> vii;",
      "",
      "const int INF = 1e9;",
      "",
      "vi spfa(int V, vector<vii>& AL, int s) {",
      "  vi dist(V, INF); dist[s] = 0;",
      "  queue<int> q; q.push(s);",
      "  vi in_queue(V, 0); in_queue[s] = 1;",
      "  while (!q.empty()) {",
      "    int u = q.front(); q.pop(); in_queue[u] = 0;",
      "    for (auto &[v, w] : AL[u]) {",
      "      if (dist[u]+w >= dist[v]) continue;",
      "      dist[v] = dist[u]+w;",
      "      if (!in_queue[v]) {",
      "        q.push(v);",
      "        in_queue[v] = 1;",
      "      }",
      "    }",
      "  }",
      "  return dist;",
      "}"
    ],
    "description": "SPFA (Shortest Path Faster Algorithm) - optimized Bellman Ford",
    "scope": "cpp"
  },

  "BFS Unweighted SSSP": {
    "prefix": "bfs",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<ii> vii;",
      "typedef vector<int> vi;",
      "",
      "const int INF = 1e9;",
      "",
      "vi p;",
      "",
      "void printPath(int u) {",
      "  if (p[u] == -1) { printf(\"%d\", u); return; }",
      "  printPath(p[u]);",
      "  printf(\" %d\", u);",
      "}",
      "",
      "pair<vi, bool> bfs(int V, vector<vii>& AL, int s) {",
      "  vi dist(V, INF); dist[s] = 0;",
      "  queue<int> q; q.push(s);",
      "  p.assign(V, -1);",
      "  bool isBipartite = true;",
      "  ",
      "  while (!q.empty()) {",
      "    int u = q.front(); q.pop();",
      "    for (auto &[v, w] : AL[u]) {",
      "      if (dist[v] == INF) {",
      "        dist[v] = dist[u]+1;",
      "        p[v] = u;",
      "        q.push(v);",
      "      }",
      "      else if ((dist[v]%2) == (dist[u]%2))",
      "        isBipartite = false;",
      "    }",
      "  }",
      "  return {dist, isBipartite};",
      "}"
    ],
    "description": "BFS for unweighted shortest path with bipartite check (O(V+E))",
    "scope": "cpp"
  },

  "Dijkstra SSSP": {
    "prefix": "dijkstra",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<int> vi;",
      "typedef vector<ii> vii;",
      "",
      "const int INF = 1e9;",
      "",
      "vi dijkstra(int V, vector<vii>& AL, int s) {",
      "  vi dist(V, INF); dist[s] = 0;",
      "  priority_queue<ii, vector<ii>, greater<ii>> pq;",
      "  pq.push({0, s});",
      "  ",
      "  while (!pq.empty()) {",
      "    auto [d, u] = pq.top(); pq.pop();",
      "    if (d > dist[u]) continue;",
      "    for (auto &[v, w] : AL[u]) {",
      "      if (dist[u]+w >= dist[v]) continue;",
      "      dist[v] = dist[u]+w;",
      "      pq.push({dist[v], v});",
      "    }",
      "  }",
      "  return dist;",
      "}"
    ],
    "description": "Dijkstra's algorithm for SSSP with non-negative weights (O(E log V))",
    "scope": "cpp"
  }
}
