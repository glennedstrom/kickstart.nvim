{
  "DFS Connected Components": {
    "prefix": "dfscc",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<ii> vii;",
      "typedef vector<int> vi;",
      "",
      "enum { UNVISITED = -1, VISITED = -2 };",
      "",
      "vector<vii> AL;",
      "vi dfs_num;",
      "",
      "void dfs(int u) {",
      "  printf(\" %d\", u);",
      "  dfs_num[u] = VISITED;",
      "  for (auto &[v, w] : AL[u])",
      "    if (dfs_num[v] == UNVISITED)",
      "      dfs(v);",
      "}",
      "",
      "void findConnectedComponents(int V) {",
      "  dfs_num.assign(V, UNVISITED);",
      "  int numCC = 0;",
      "  for (int u = 0; u < V; ++u)",
      "    if (dfs_num[u] == UNVISITED)",
      "      printf(\"CC %d:\", ++numCC), dfs(u), printf(\"\\n\");",
      "  printf(\"There are %d connected components\\n\", numCC);",
      "}"
    ],
    "description": "DFS to find connected components in undirected graph",
    "scope": "cpp"
  },

  "Cycle Detection": {
    "prefix": "cyclecheck",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<ii> vii;",
      "typedef vector<int> vi;",
      "",
      "enum { UNVISITED = -1, EXPLORED = -2, VISITED = -3 };",
      "",
      "vector<vii> AL;",
      "vi dfs_num;",
      "vi dfs_parent;",
      "",
      "void cycleCheck(int u) {",
      "  dfs_num[u] = EXPLORED;",
      "  for (auto &[v, w] : AL[u]) {",
      "    if (dfs_num[v] == UNVISITED) {",
      "      dfs_parent[v] = u;",
      "      cycleCheck(v);",
      "    }",
      "    else if (dfs_num[v] == EXPLORED) {",
      "      if (v == dfs_parent[u])",
      "        printf(\" Bidirectional Edge (%d, %d)-(%d, %d)\\n\", u, v, v, u);",
      "      else",
      "        printf(\"Back Edge (%d, %d) (Cycle)\\n\", u, v);",
      "    }",
      "    else if (dfs_num[v] == VISITED)",
      "      printf(\"  Forward/Cross Edge (%d, %d)\\n\", u, v);",
      "  }",
      "  dfs_num[u] = VISITED;",
      "}",
      "",
      "void checkCycles(int V) {",
      "  dfs_num.assign(V, UNVISITED);",
      "  dfs_parent.assign(V, -1);",
      "  for (int u = 0; u < V; ++u)",
      "    if (dfs_num[u] == UNVISITED)",
      "      cycleCheck(u);",
      "}"
    ],
    "description": "Cycle detection and edge classification using DFS",
    "scope": "cpp"
  },

  "Topological Sort": {
    "prefix": "toposort",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<ii> vii;",
      "typedef vector<int> vi;",
      "",
      "enum { UNVISITED = -1, VISITED = -2 };",
      "",
      "vector<vii> AL;",
      "vi dfs_num;",
      "vi ts;",
      "",
      "void toposort(int u) {",
      "  dfs_num[u] = VISITED;",
      "  for (auto &[v, w] : AL[u])",
      "    if (dfs_num[v] == UNVISITED)",
      "      toposort(v);",
      "  ts.push_back(u);",
      "}",
      "",
      "vi topologicalSort(int V) {",
      "  dfs_num.assign(V, UNVISITED);",
      "  ts.clear();",
      "  for (int u = 0; u < V; ++u)",
      "    if (dfs_num[u] == UNVISITED)",
      "      toposort(u);",
      "  reverse(ts.begin(), ts.end());",
      "  return ts;",
      "}"
    ],
    "description": "Topological sort for directed acyclic graphs (DAG)",
    "scope": "cpp"
  },

  "Articulation Points and Bridges": {
    "prefix": "articulation",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<ii> vii;",
      "typedef vector<int> vi;",
      "",
      "enum { UNVISITED = -1 };",
      "",
      "vector<vii> AL;",
      "vi dfs_num, dfs_low, dfs_parent, articulation_vertex;",
      "int dfsNumberCounter, dfsRoot, rootChildren;",
      "",
      "void articulationPointAndBridge(int u) {",
      "  dfs_low[u] = dfs_num[u] = dfsNumberCounter++;",
      "  for (auto &[v, w] : AL[u]) {",
      "    if (dfs_num[v] == UNVISITED) {",
      "      dfs_parent[v] = u;",
      "      if (u == dfsRoot) ++rootChildren;",
      "",
      "      articulationPointAndBridge(v);",
      "",
      "      if (dfs_low[v] >= dfs_num[u])",
      "        articulation_vertex[u] = 1;",
      "      if (dfs_low[v] > dfs_num[u])",
      "        printf(\" Edge (%d, %d) is a bridge\\n\", u, v);",
      "      dfs_low[u] = min(dfs_low[u], dfs_low[v]);",
      "    }",
      "    else if (v != dfs_parent[u])",
      "      dfs_low[u] = min(dfs_low[u], dfs_num[v]);",
      "  }",
      "}",
      "",
      "void findArticulationPointsAndBridges(int V) {",
      "  dfs_num.assign(V, UNVISITED); dfs_low.assign(V, 0);",
      "  dfs_parent.assign(V, -1); articulation_vertex.assign(V, 0);",
      "  dfsNumberCounter = 0;",
      "  printf(\"Bridges:\\n\");",
      "  for (int u = 0; u < V; ++u)",
      "    if (dfs_num[u] == UNVISITED) {",
      "      dfsRoot = u; rootChildren = 0;",
      "      articulationPointAndBridge(u);",
      "      articulation_vertex[dfsRoot] = (rootChildren > 1);",
      "    }",
      "",
      "  printf(\"Articulation Points:\\n\");",
      "  for (int u = 0; u < V; ++u)",
      "    if (articulation_vertex[u])",
      "      printf(\" Vertex %d\\n\", u);",
      "}"
    ],
    "description": "Find articulation points (cut vertices) and bridges (cut edges) in undirected graph",
    "scope": "cpp"
  }
}
