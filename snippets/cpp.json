{
  "vector_operators": {
    "prefix": "vector_operators",
    "body": [
      "namespace vector_operators {",
      "    template<typename T> vector<T>& operator*=(vector<T>& l, const T& r) {",
      "        for (T& e : l) e *= r; return l;",
      "    }",
      "    template<typename T> vector<T>& operator/=(vector<T>& l, const T& r) {",
      "        for (T& e : l) e /= r; return l;",
      "    }",
      "    template<typename T> vector<T> operator*(vector<T> l, const T& r) { return l *= r; }",
      "    template<typename T> vector<T> operator*(const T& l, vector<T> r) { return r *= l; }",
      "    template<typename T> vector<T> operator/(vector<T> l, const T& r) { return l /= r; }",
      "",
      "    template<typename T> vector<T>& operator+=(vector<T>& l, vector<T>& r) {",
      "        l.resz(max(sz(l), sz(r))); for (int i = 0; i < sz(r); i++) l[i] += r[i]; return l;",
      "    }",
      "    template<typename T> vector<T>& operator-=(vector<T>& l, const vector<T>& r) {",
      "        l.resz(max(sz(l), sz(r))); for (int i = 0; i < sz(r); i++) l[i] -= r[i]; return l;",
      "    }",
      "    template<typename T> vector<T> operator+(vector<T> l, const vector<T>& r) { return l += r; }",
      "    template<typename T> vector<T> operator-(vector<T> l, const vector<T>& r) { return l -= r; }",
      "",
      "    template<typename T> vector<T> conv(const vector<T>& l, const vector<T>& r) {",
      "        if (l.empty() || r.empty()) return {};",
      "        vector<T> p(sz(l) + sz(r) - 1);",
      "        for (int i = 0; i < sz(l); i++) for (int j = 0; j < sz(r); j++) p[i+j] += l[i] * r[j];",
      "        return p;",
      "    }",
      "    template<typename T> vector<T> operator*(const vector<T>& l, const vector<T>& r) {",
      "        return complex_fft::conv(l, r); // return conv(l, r);",
      "    }",
      "",
      "    template<typename T> vector<T> dot(const vector<T>& a, const vector<T>& b) {",
      "        vector<T> p(min(sz(a), sz(b))); for (int i = 0; i < sz(p); i++) p[i] = a[i] * b[i]; return p;",
      "    }",
      "",
      "    template<typename T> vector<T>& operator<<=(vector<T>& v, int x) {",
      "        v.insert(v.begin(), x, 0); return v;",
      "    }",
      "    template<typename T> vector<T> operator<<(vector<T> v, int x) { return v <<= x; }",
      "",
      "    template<typename T> void rem_lead(vector<T>& v) { while (sz(v) && v.back() == 0) v.pop_back(); }",
      "    template<typename T> vector<T> without_lead(vector<T> v) { rem_lead(v); return v; }",
      "",
      "    template<typename T> vector<T> reversed(vector<T> v) {",
      "        reverse(all(v)); rem_lead(v); return v;",
      "    }",
      "    template<typename T> vector<T> reversed(const vector<T>& v, int S) {",
      "        assert(S >= sz(v)); vector<T> res(S); copy(all(v), res.rbegin()); return res;",
      "    }",
      "",
      "    template<typename T> pair<vector<T>, vector<T>> long_division(vector<T> a, vector<T> b) {",
      "        rem_lead(a), rem_lead(b), assert(!b.empty());",
      "        T B = T{1} / b.back(); for (T& e : b) e *= B;",
      "        vector<T> q(max(sz(a) - sz(b) + 1, 0));",
      "        for (; sz(a) >= sz(b); rem_lead(a)) {",
      "            q[sz(a) - sz(b)] = a.back();",
      "            a -= a.back() * (b << (sz(a) - sz(b)));",
      "        }",
      "        for (T& e : q) e *= B;",
      "        return {q, a}; // quotient, remainder",
      "    }",
      "",
      "    template<typename T> vector<T> mod_xk(const vector<T>& v, int k) {",
      "        vector<T> r{v.begin(), v.begin() + min(sz(v), k)}; rem_lead(r); return r;",
      "    }",
      "    // 1/v % x^k",
      "    template<typename T> vector<T> inv(const vector<T>& v, int k) {",
      "        assert(!v.empty());",
      "        if (k == 0) return {};",
      "        if (k == 1) return { T{1}/v[0] };",
      "        vector<T> v0 = inv(v, (k + 1)/2);",
      "        return mod_xk(v0 * (vector<T>{2} - v0 * mod_xk(v, k)), k);",
      "    }",
      "    // Fast quotient and remainder by multiplying with inverse if you have an FFT",
      "    template<typename T> vector<T> quo(vector<T> a, vector<T> b) {",
      "        if (sz(a) < sz(b)) return {0};",
      "        rem_lead(a), rem_lead(b), assert(!b.empty());",
      "        int s = sz(a) + 1 - sz(b);",
      "        return reversed(mod_xk(reversed(a) * inv(reversed(b), s), s), s);",
      "    }",
      "    template<typename T> vector<T> rem(const vector<T>& a, const vector<T>& b) {",
      "        return without_lead(sz(a) < sz(b) ? a : (a - quo(a, b) * b));",
      "    }",
      "",
      "    template<typename T> vector<T>& operator/=(vector<T>& a, const vector<T>& b) {",
      "        return a = min(sz(a), sz(b)) < FFT_CUTOFF ? long_division(a, b).first  : quo(a, b);",
      "    }",
      "    template<typename T> vector<T>& operator%=(vector<T>& a, const vector<T>& b) {",
      "        return a = min(sz(a), sz(b)) < FFT_CUTOFF ? long_division(a, b).second : rem(a, b);",
      "    }",
      "    template<typename T> vector<T> operator/(vector<T> a, const vector<T>& b) { return a /= b; }",
      "    template<typename T> vector<T> operator%(vector<T> a, const vector<T>& b) { return a %= b; }",
      "",
      "    template<typename T> vector<T> mod_pow(const vector<T>& v, ll e, const vector<T>& m) {",
      "        if (!e) return {1};",
      "        vector<T> res = mod_pow(v, e/2, m); res = res * res % m;",
      "        return e&1 ? res * v % m : res;",
      "    }",
      "",
      "    // evaluate polynomial v at x0",
      "    template<typename T> T operator|(const vector<T>& v, const T& x0) {",
      "        T res = 0; for (int i = sz(v) - 1; i >= 0; --i) res = res * x0 + v[i]; return res;",
      "    }",
      "}"
    ],
    "description": "vector_operators"
  },
  "matrix": {
    "prefix": "matrix",
    "body": [
      "#include <vector>",
      "#include <iostream>",
      "#include <iomanip>",
      "",
      "template<typename T>",
      "struct matrix {",
      "    int N, M;",
      "    std::vector<T> data;",
      "",
      "    matrix(int _N, int _M, T value = T{}) : N(_N), M(_M), data(N * M, value) {}",
      "",
      "    typename std::vector<T>::iterator operator[](int i) {",
      "        return data.begin() + i * M;",
      "    }",
      "    typename std::vector<T>::const_iterator operator[](int i) const {",
      "        return data.begin() + i * M;",
      "    }",
      "",
      "    friend matrix<T> operator * (const matrix<T>& a, const matrix<T>& b) {",
      "        assert(a.M == b.N);",
      "        matrix<T> res(a.N, b.M);",
      "        for (int i = 0; i < a.N; i++)",
      "            for (int k = 0; k < a.M; k++)",
      "                for (int j = 0; j < b.M; j++)",
      "                    res[i][j] += a[i][k] * b[k][j];",
      "        return res;",
      "    }",
      "",
      "    friend std::vector<T> operator * (const std::vector<T>& v, const matrix<T>& m) {",
      "        assert(sz(v) == m.N);",
      "        std::vector<T> res(m.M);",
      "        for (int i = 0; i < m.N; i++)",
      "            for (int j = 0; j < m.M; j++)",
      "                res[j] += v[i] * m[i][j];",
      "        return res;",
      "    }",
      "",
      "    friend std::vector<T> operator * (const matrix<T>& m, const std::vector<T>& v) {",
      "        assert(m.M == sz(v));",
      "        std::vector<T> res(m.N);",
      "        for (int i = 0; i < m.N; i++)",
      "            for (int j = 0; j < m.M; j++)",
      "                res[i] += m[i][j] * v[j];",
      "        return res;",
      "    }",
      "",
      "    matrix pow(int64_t e) const {",
      "        assert(N == M);",
      "        if (e == 0) return matrix<T>(N, N, 0, 1);",
      "        if (e&1) return *this * pow(e - 1);",
      "        return (*this * *this).pow(e / 2);",
      "    }",
      "",
      "    friend void row_reduce(matrix<T> &m) {",
      "        int rank = 0;",
      "        for (int j = 0; j < m.M && rank < m.N; j++) {",
      "            for (int i = rank; i < m.N; i++) {",
      "                if (m[i][j] != 0) {",
      "                    swap_ranges(m[rank], m[rank] + m.M, m[i]);",
      "                    break;",
      "                }",
      "            }",
      "            if (m[rank][j] == 0)",
      "                continue;",
      "",
      "            T inv = 1 / m[rank][j];",
      "            for (int k = j; k < m.M; k++)",
      "                m[rank][k] *= inv;",
      "",
      "            for (int i = 0; i < m.N; i++) {",
      "                if (i != rank) {",
      "                    T c = m[i][j];",
      "                    for (int k = j; k < m.M; k++)",
      "                        m[i][k] -= c * m[rank][k];",
      "                }",
      "            }",
      "            rank++;",
      "        }",
      "",
      "        m.N = rank;",
      "        m.data.resize(m.N * m.M);",
      "    }",
      "",
      "    friend std::ostream& operator << (std::ostream& os, const matrix<T>& m) {",
      "        for (int i = 0; i < m.N; i++) {",
      "            os << (i ? i < m.N - 1 ? \"\\u2503\" : \"\\u2517\" : \"\\n\\u250F\");",
      "            for (int j = 0; j < m.M; j++)",
      "                os << std::setw(12) << m[i][j];",
      "            os << \"  \" << (i ? i < m.N - 1 ? \"\\u2503\" : \"\\u251B\" : \"\\u2512\") << \"\\n\";",
      "        }",
      "        return os;",
      "    }",
      "};"
    ],
    "description": "matrix"
  },
  "matrix_array": {
    "prefix": "matrix_array",
    "body": [
      "/* Equivalent to matrix.cpp, but with data stored in std::array.",
      " * Useful when matrix dimensions are known at compile time",
      " * and you want locality for a vector<matrix>. */",
      "template<typename T, int N, int M> struct matrix : array<array<T,M>,N> {",
      "    matrix<T,N,M> (T f = 0, T d = 0) {",
      "        for (array<T,M>& row : *this) row.fill(f);",
      "        for (int i = 0; i < min(N, M); i++) ((*this)[i])[i] = d;",
      "    }",
      "",
      "    matrix<T,N,M> (const initializer_list<T>& init) {",
      "        assert(sz(init) == N * M);",
      "        auto it = init.begin();",
      "        for (array<T,M>& row : *this) {",
      "            copy(it, it + M, row.data());",
      "            it += M;",
      "        }",
      "    }",
      "",
      "    template<int P>",
      "    friend matrix<T,N,M> operator*(const matrix<T,N,P>& a, const matrix<T,P,M>& b) {",
      "        matrix<T,N,M> res{};",
      "        for (int i = 0; i < N; i++)",
      "            for (int j = 0; j < M; j++)",
      "                for (int k = 0; k < M; k++)",
      "                    res[i][j] += a[i][k] * b[k][j];",
      "        return res;",
      "    }",
      "",
      "    friend vector<T> operator*(const vector<T>& v, const matrix<T,N,M>& m) {",
      "        assert(N == sz(v));",
      "        vector<T> res(M);",
      "        for (int j = 0; j < M; j++)",
      "            for (int i = 0; i < N; i++)",
      "                res[j] += v[i] * m[i][j];",
      "        return res;",
      "    }",
      "",
      "    friend vector<T> operator*(const matrix<T,N,M>& m, const vector<T>& v) {",
      "        assert(M == sz(v));",
      "        vector<T> res(N);",
      "        for (int i = 0; i < N; i++)",
      "            for (int j = 0; j < M; j++)",
      "                res[i] += m[i][j] * v[j];",
      "        return res;",
      "    }",
      "",
      "    matrix pow(ll e) const {",
      "        assert(N == M);",
      "        if (e == 0) return matrix<T,N,M>(N, M, 0, 1);",
      "        if (e&1) return *this * pow(e - 1);",
      "        return (*this * *this).pow(e / 2);",
      "    }",
      "",
      "    int rank() const {",
      "        matrix<T,N,M> m = *this;",
      "        int r = 0;",
      "        for (int j = 0; j < M; j++) {",
      "            for (int i = r; i < N; i++) if (m[i][j] != 0) {",
      "                swap_ranges(m[r], m[r] + M, m[i]);",
      "                break;",
      "            }",
      "            if (m[r][j] == 0) continue;",
      "",
      "            for (int i = 0; i < N; i++) if (i != r) {",
      "                T c = m[i][j] / m[r][j];",
      "                for (int k = 0; k < M; k++)",
      "                    m[i][k] -= c * m[r][k];",
      "            }",
      "            r++;",
      "        }",
      "        return r;",
      "    }",
      "",
      "    friend ostream& operator <<(ostream& os, const matrix<T,N,M>& m) {",
      "        for (int i = 0; i < N; i++) {",
      "            os << (i ? i < N - 1 ? \"\\u2503\" : \"\\u2517\" : \"\\n\\u250F\");",
      "            for (int j = 0; j < M; j++)",
      "                os << setw(12) << m[i][j];",
      "            os << \"  \" << (i ? i < m.N - 1 ? \"\\u2503\" : \"\\u251B\" : \"\\u2512\") << \"\\n\";",
      "        }",
      "        return os;",
      "    }",
      "};"
    ],
    "description": "matrix_array"
  },
  "berlekamp-massey": {
    "prefix": "berlekamp-massey",
    "body": [
      "template<typename T> struct LFSR {",
      "    vector<T> seq;    // original sequence",
      "    vector<T> fib;    // seq[i] = sum_j fib[j] * seq[i-1-j] (i >= sz(fib))",
      "    vector<T> galois; // 0 = sum_j galois[j] * seq[i+j] (i <= sz(seq) - sz(galois))",
      "",
      "    LFSR(vector<T> seq_) : seq(seq_) {",
      "        vector<T> C = {1}, B = {1}; T b = 1;",
      "        for (int i = 0, m = 1; i < sz(seq); i++, m++) {",
      "            T d = 0; for (int j = 0; j < sz(C); j++) d += C[j] * seq[i - j];",
      "            if (d == 0) continue;",
      "            vector<T> B_ = C; C.resz(max(sz(C), m+sz(B)));",
      "            T dbi = d/b; for (int j = 0; j < sz(B); j++) C[m+j] -= dbi * B[j];",
      "            if (sz(B_) < m+sz(B)) { B = B_; b = d; m = 0; }",
      "        }",
      "        galois = reversed(C);",
      "        fib = move(C); fib.erase(fib.begin()); fib *= T{-1};",
      "    }",
      "",
      "    T operator[](ll n) const {",
      "        vector<T> r = dot(seq, mod_pow({0,1}, n, galois));",
      "        return accumulate(all(r), T{0});",
      "    }",
      "};"
    ],
    "description": "berlekamp-massey"
  },
  "discrete_logarithm": {
    "prefix": "discrete_logarithm",
    "body": [
      "// {{{ data_structures/splitmix64_hash_map.cpp }}}",
      "",
      "#include <cstdint>",
      "#include <numeric>",
      "",
      "int product(int x, int y, int MOD) {",
      "    return int(int64_t(x) * y % MOD);",
      "}",
      "",
      "int mod_pow(int x, int k, int MOD) {",
      "    if (!k) return 1;",
      "    if (k&1) return product(x, mod_pow(x, k - 1, MOD), MOD);",
      "    return mod_pow(product(x, x, MOD), k / 2, MOD);",
      "}",
      "",
      "int totient(int v) {",
      "    int tot = v;",
      "    for (int p = 2; p * p <= v; p++) if (v % p == 0) {",
      "        tot = tot / p * (p - 1);",
      "        while (v % p == 0) v /= p;",
      "    }",
      "    if (v > 1) tot = tot / v * (v - 1);",
      "    return tot;",
      "}",
      "",
      "/* Returns the smallest K >= 0 such that init * pow(x, K) === y modulo MOD.",
      " * Returns -1 if no such K exists. Runs in O(sqrt(MOD)).",
      " */",
      "int discrete_log(int x, int y, int MOD, int init = 1) {",
      "    if (x == 0)",
      "        return y == 1 ? 0 : y == 0 ? MOD > 1 : -1;",
      "",
      "    int prefix = 0;",
      "    while (init != y && std::gcd(init, MOD) != std::gcd(product(init, x, MOD), MOD)) {",
      "        init = product(init, x, MOD);",
      "        prefix++;",
      "    }",
      "",
      "    if (init == y)",
      "        return prefix;",
      "",
      "    if (std::gcd(init, MOD) != std::gcd(y, MOD))",
      "        return -1;",
      "",
      "    MOD = MOD / std::gcd(init, MOD);",
      "",
      "    x %= MOD;",
      "    y %= MOD;",
      "    init %= MOD;",
      "",
      "    int subgroup_order = totient(MOD);",
      "",
      "    y = product(y, mod_pow(init, subgroup_order - 1, MOD), MOD);",
      "",
      "    int step_size = 0;",
      "    while (step_size * step_size < subgroup_order)",
      "        step_size++;",
      "",
      "    umap<int, int> table;",
      "",
      "    int baby_step = 1;",
      "    for (int i = 0; i < step_size; i++) {",
      "        table[baby_step] = i;",
      "        baby_step = product(baby_step, x, MOD);",
      "    }",
      "",
      "    int giant_step = mod_pow(x, subgroup_order - step_size, MOD);",
      "    for (int i = 0; i < step_size; i++) {",
      "        auto it = table.find(y);",
      "        if (it != table.end())",
      "            return prefix + i * step_size + it->second;",
      "        y = product(y, giant_step, MOD);",
      "    }",
      "",
      "    return -1;",
      "}"
    ],
    "description": "discrete_logarithm"
  },
  "frac": {
    "prefix": "frac",
    "body": [
      "template<typename v_t = long long> struct frac {",
      "    v_t n, d;",
      "    frac(v_t _n, v_t _d = 1) : n(_n), d(_d) {",
      "        assert(n != 0 || d != 0);",
      "        if (d < 0) { n *= -1; d *= -1; }",
      "        v_t g = __gcd(abs(n), d);",
      "        n /= g;",
      "        d /= g;",
      "    }",
      "    friend ostream& operator << (ostream& o, const frac& f) {",
      "        return o << f.n << \"/\" << f.d;",
      "    }",
      "",
      "#define define_relational_operator(OP) \\",
      "    friend bool operator OP (const frac& a, const frac& b) { \\",
      "        return a.n * b.d OP b.n * a.d; \\",
      "    }",
      "    define_relational_operator(<)",
      "    define_relational_operator(<=)",
      "    define_relational_operator(==)",
      "    define_relational_operator(!=)",
      "    define_relational_operator(>)",
      "    define_relational_operator(>=)",
      "",
      "    friend frac min(const frac a, const frac b) { return a <= b ? a : b; }",
      "    friend frac max(const frac a, const frac b) { return a >= b ? a : b; }",
      "",
      "    frac& operator += (const frac& b) { return *this = frac(n*b.d+b.n*d, d*b.d); }",
      "    frac& operator -= (const frac& b) { return *this = frac(n*b.d-b.n*d, d*b.d); }",
      "    frac& operator *= (const frac& b) { return *this = frac(n*b.n, d*b.d); }",
      "    frac& operator /= (const frac& b) { return *this = frac(n*b.d, d*b.n); }",
      "    friend frac operator + (const frac& a, const frac& b) { return frac(a) += b; }",
      "    friend frac operator - (const frac& a, const frac& b) { return frac(a) -= b; }",
      "    friend frac operator * (const frac& a, const frac& b) { return frac(a) *= b; }",
      "    friend frac operator / (const frac& a, const frac& b) { return frac(a) /= b; }",
      "",
      "    explicit operator double() const { return double(n)/d; }",
      "    v_t floor() { assert(d > 0); return n / d - ((n < 0) && (n % d)); }",
      "    v_t ceil() { assert(d > 0); return n / d + ((n > 0) && (n % d)); }",
      "",
      "    // canonical continued fraction",
      "    vector<v_t> to_cont() const {",
      "        if (d == 0) return { LLONG_MAX };",
      "        vector<v_t> cont;",
      "        for (v_t n = this->n, d = this->d; ; swap(n, d)) {",
      "            v_t f = (n >= 0 ? n : n - d + 1) / d;",
      "            cont.push_back(f);",
      "            n -= f * d;",
      "            if (n == 0) break;",
      "        }",
      "        return cont;",
      "    }",
      "",
      "    static frac from_cont(const vector<v_t>& cont) {",
      "        v_t n = 1, d = 0;",
      "        for (int i = int(cont.size()) - 1; i >= 0; i--) {",
      "            swap(n, d);",
      "            n += d * cont[i];",
      "        }",
      "        return { n, d };",
      "    }",
      "",
      "    // \"best\" fraction in (x, y): minimizes both n and d",
      "    friend frac best_in(const frac x, const frac y) {",
      "        assert(x < y);",
      "",
      "        vector<v_t> x1 = x.to_cont(), y1 = y.to_cont();",
      "        vector<v_t> x2 = x1; x2.back()--; x2.push_back(1);",
      "        vector<v_t> y2 = y1; y2.back()--; y2.push_back(1);",
      "",
      "        auto z = [](const vector<v_t>& a, const vector<v_t>& b) {",
      "            vector<v_t> c;",
      "            for (int i = 0; ; i++) {",
      "                v_t ai = i < a.size() ? a[i] : LLONG_MAX;",
      "                v_t bi = i < b.size() ? b[i] : LLONG_MAX;",
      "                if (ai != bi) {",
      "                    c.push_back(min(ai, bi) + 1);",
      "                    return from_cont(c);",
      "                }",
      "                c.push_back(ai);",
      "            }",
      "        };",
      "",
      "        frac ans = { 1, 0 };",
      "        for (const frac f : {z(x1, y1), z(x1, y2), z(x2, y1), z(x2, y2)}) {",
      "            if (x < f && f < y && (ans.d == 0 || f.d < ans.d))",
      "                ans = f;",
      "        }",
      "        return ans;",
      "    }",
      "};"
    ],
    "description": "frac"
  },
  "complex_fft": {
    "prefix": "complex_fft",
    "body": [
      "// {{{ numeric/modnum.cpp }}}",
      "// {{{ numeric/point.cpp }}}",
      "// {{{ numeric/fft.cpp }}}",
      "",
      "#include <vector>",
      "#include <climits>",
      "",
      "namespace complex_fft {",
      "    using dbl = double;",
      "    struct cnum : point<dbl> {",
      "        cnum(point<dbl> p) : point<dbl>(p) {}",
      "        cnum(dbl _x = 0, dbl _y = 0) : point<dbl>(_x, _y) {}",
      "        cnum inv() const { dbl n = norm(); return cnum(x / n, -y / n); }",
      "",
      "        static cnum unity_root(int deg, int pow) {",
      "            static std::vector<cnum> table{ 0, 1 };",
      "            while (int(table.size()) <= deg) {",
      "                dbl t = 2 * acos(-1) / table.size();",
      "                cnum w{ cos(t), sin(t) };",
      "                for (int s = int(table.size()), i = s / 2; i < s; i++) {",
      "                    table.push_back(table[i]);",
      "                    table.push_back(table[i] * w);",
      "                }",
      "            }",
      "            return table[deg + (pow < 0 ? deg + pow : pow)];",
      "        }",
      "    };",
      "",
      "    static std::vector<cnum> fa, fb;",
      "",
      "    std::vector<cnum> operator*(const std::vector<cnum>& a, const std::vector<cnum>& b) {",
      "        if (a.empty() || b.empty())",
      "            return {};",
      "",
      "        int s = int(a.size()) + int(b.size()) - 1;",
      "",
      "        int N = 1 << (s > 1 ? 32 - __builtin_clz(s - 1) : 0);",
      "        if (N > int(fa.size())) fa.resize(N), fb.resize(N);",
      "",
      "        copy(a.begin(), a.end(), fa.begin());",
      "        fill(fa.begin() + a.size(), fa.begin() + N, 0);",
      "        copy(b.begin(), b.end(), fb.begin());",
      "        fill(fb.begin() + b.size(), fb.begin() + N, 0);",
      "",
      "        fft(fa.begin(), fa.begin() + N, false);",
      "        fft(fb.begin(), fb.begin() + N, false);",
      "        for (int i = 0; i < N; i++) fa[i] = fa[i] * fb[i];",
      "        fft(fa.begin(), fa.begin() + N, true);",
      "",
      "        return { fa.begin(), fa.begin() + s };",
      "    }",
      "",
      "    template<int MOD>",
      "    std::vector<modnum<MOD>> operator*(const std::vector<modnum<MOD>>& a, const std::vector<modnum<MOD>>& b) {",
      "        if (a.empty() || b.empty())",
      "            return {};",
      "",
      "        int s = int(a.size()) + int(b.size()) - 1;",
      "",
      "        if (std::min(a.size(), b.size()) < FFT_CUTOFF) {",
      "            const vv_t VV_BOUND = std::numeric_limits<vv_t>::max() - vv_t(MOD) * MOD;",
      "            std::vector<vv_t> res(s);",
      "            for (int i = 0; i < int(a.size()); i++) {",
      "                for (int j = 0; j < int(b.size()); j++) {",
      "                    res[i + j] += vv_t(a[i].v) * b[j].v;",
      "                    if (res[i + j] > VV_BOUND)",
      "                        res[i + j] %= MOD;",
      "                }",
      "            }",
      "            return {res.begin(), res.end()};",
      "        }",
      "",
      "        int N = 1 << (s > 1 ? 32 - __builtin_clz(s - 1) : 0);",
      "        if (N > int(fa.size())) fa.resize(N), fb.resize(N);",
      "",
      "        for (int i = 0; i < int(a.size()); i++)",
      "            fa[i] = cnum(a[i].v & ((1 << 15) - 1), a[i].v >> 15);",
      "        fill(fa.begin() + a.size(), fa.begin() + N, 0);",
      "        fft(fa.begin(), fa.begin() + N, false);",
      "",
      "        if (a != b) {",
      "            for (int i = 0; i < int(b.size()); i++)",
      "                fb[i] = cnum(b[i].v & ((1 << 15) - 1), b[i].v >> 15);",
      "            fill(fb.begin() + b.size(), fb.begin() + N, 0);",
      "            fft(fb.begin(), fb.begin() + N, false);",
      "        } else {",
      "            copy(fa.begin(), fa.begin() + N, fb.begin());",
      "        }",
      "",
      "        for (int i = 0; i <= N / 2; i++) {",
      "            int j = (N - i) & (N - 1);",
      "            cnum g0 = (fb[i] + fb[j].conj()) / (2 * N);",
      "            cnum g1 = (fb[i] - fb[j].conj()) / (2 * N);",
      "            g1 = { g1.y, -g1.x };",
      "            if (j != i) {",
      "                std::swap(fa[j], fa[i]);",
      "                fb[j] = fa[j] * g1;",
      "                fa[j] = fa[j] * g0;",
      "            }",
      "            fb[i] = fa[i] * g1.conj();",
      "            fa[i] = fa[i] * g0.conj();",
      "        }",
      "",
      "        fft(fa.begin(), fa.begin() + N, false);",
      "        fft(fb.begin(), fb.begin() + N, false);",
      "",
      "        std::vector<modnum<MOD>> c(s);",
      "        for (int i = 0; i < s; i++)",
      "            c[i] =  vv_t(fa[i].x + 0.5)",
      "                 + (vv_t(fa[i].y + 0.5) % MOD << 15)",
      "                 + (vv_t(fb[i].x + 0.5) % MOD << 15)",
      "                 + (vv_t(fb[i].y + 0.5) % MOD << 30);",
      "        return c;",
      "    }",
      "}"
    ],
    "description": "complex_fft"
  },
  "fft": {
    "prefix": "fft",
    "body": [
      "#include <cassert>",
      "#include <algorithm>",
      "#include <type_traits>",
      "",
      "const int FFT_CUTOFF = 150;",
      "",
      "template<typename RandomAccessIterator>",
      "void fft(RandomAccessIterator first, RandomAccessIterator last, bool invert) {",
      "    int N = int(last - first);",
      "    assert(__builtin_popcount(N) == 1);",
      "",
      "    for (int i = 1, j = 0, k; i < N; i++) {",
      "        for (k = N >> 1; (j ^= k) < k; k >>= 1);",
      "        if (i < j) std::swap(first[i], first[j]);",
      "    }",
      "",
      "    using T = typename std::remove_reference<decltype(*first)>::type;",
      "",
      "    for (int l = 1; l < N; l <<= 1) {",
      "        for (int i = 0; i < N; i += 2 * l) {",
      "            for (int j = 0; j < l; j++) {",
      "                T w = T::unity_root(2 * l, invert ? -j : j);",
      "                T u = first[i + j];",
      "                T v = first[i + j + l] * w;",
      "                first[i + j] = u + v;",
      "                first[i + j + l] = u - v;",
      "            }",
      "        }",
      "    }",
      "",
      "    if (invert) {",
      "        T N_inverse = T{N}.inv();",
      "",
      "        for (int i = 0; i < N; i++)",
      "            first[i] = first[i] * N_inverse;",
      "    }",
      "}"
    ],
    "description": "fft"
  },
  "ntt": {
    "prefix": "ntt",
    "body": [
      "// {{{ numeric/modnum.cpp }}}",
      "// {{{ numeric/fft.cpp }}}",
      "",
      "#include <vector>",
      "#include <climits>",
      "",
      "namespace ntt {",
      "    template<int MOD>",
      "    std::vector<modnum<MOD>> operator*(std::vector<modnum<MOD>> a, std::vector<modnum<MOD>> b) {",
      "        if (a.empty() || b.empty()) return {};",
      "        int s = int(a.size()) + int(b.size()) - 1;",
      "        if (std::min(a.size(), b.size()) < FFT_CUTOFF) {",
      "            const vv_t VV_BOUND = std::numeric_limits<vv_t>::max() - vv_t(MOD) * MOD;",
      "            std::vector<vv_t> res(s);",
      "            for (int i = 0; i < int(a.size()); i++) {",
      "                for (int j = 0; j < int(b.size()); j++) {",
      "                    res[i + j] += vv_t(a[i].v) * b[j].v;",
      "                    if (res[i + j] > VV_BOUND)",
      "                        res[i + j] %= MOD;",
      "                }",
      "            }",
      "            return {res.begin(), res.end()};",
      "        }",
      "",
      "        int N = 1 << (s > 1 ? 32 - __builtin_clz(s - 1) : 0);",
      "",
      "        bool eq = a == b;",
      "        a.resize(N);",
      "        fft(a.begin(), a.end(), false);",
      "",
      "        if (!eq) {",
      "            b.resize(N);",
      "            fft(b.begin(), b.end(), false);",
      "            for (int i = 0; i < N; i++) a[i] *= b[i];",
      "        } else {",
      "            for (int i = 0; i < N; i++) a[i] *= a[i];",
      "        }",
      "",
      "        fft(a.begin(), a.end(), true);",
      "        a.resize(s);",
      "        return a;",
      "    }",
      "",
      "    template<int MOD>",
      "    std::vector<modnum<MOD>> pow(std::vector<modnum<MOD>> v, int p) {",
      "        std::vector<modnum<MOD>> r = {1};",
      "        if (!p) return r;",
      "        for (int i = 31 - __builtin_clz(p); i >= 0; --i) {",
      "            r = r * r;",
      "            if (p & (1 << i)) r = r * v;",
      "        }",
      "        return r;",
      "    }",
      "}"
    ],
    "description": "ntt"
  },
  "modnum": {
    "prefix": "modnum",
    "body": [
      "#include <cstdint>",
      "#include <cassert>",
      "#include <limits>",
      "#include <iostream>",
      "#include <vector>",
      "#include <numeric>",
      "#include <cmath>",
      "#include <unordered_map>",
      "",
      "using v_t = int;",
      "using vv_t = int64_t;",
      "",
      "template<v_t MOD> struct modnum {",
      "    static_assert(std::numeric_limits<v_t>::max() / 2 >= MOD, \"Addition overflows v_t\");",
      "    static_assert(std::numeric_limits<vv_t>::max() / MOD >= MOD, \"Multiplication overflows vv_t\");",
      "",
      "    v_t v;",
      "    modnum() : v(0) {}",
      "    modnum(vv_t _v) : v(v_t(_v % MOD)) { if (v < 0) v += MOD; }",
      "    explicit operator v_t() const { return v; }",
      "    friend std::istream& operator >> (std::istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }",
      "    friend std::ostream& operator << (std::ostream& o, const modnum& n) { return o << n.v; }",
      "",
      "    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
      "    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
      "    friend bool operator <  (const modnum& a, const modnum& b) { return a.v <  b.v; }",
      "",
      "    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {",
      "#if !defined(_WIN32) || defined(_WIN64)",
      "        return unsigned(x % m);",
      "#endif",
      "        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.",
      "        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x), quot, rem;",
      "        asm(\"divl %4\\n\"",
      "                : \"=a\" (quot), \"=d\" (rem)",
      "                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));",
      "        return rem;",
      "    }",
      "",
      "    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }",
      "    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }",
      "    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }",
      "    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }",
      "    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
      "    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
      "    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
      "",
      "    modnum pow(vv_t e) const {",
      "        if (e < 0) return 1 / this->pow(-e);",
      "        if (e == 0) return 1;",
      "        if (e & 1) return *this * this->pow(e-1);",
      "        return (*this * *this).pow(e/2);",
      "    }",
      "",
      "    modnum inv() const {",
      "        v_t g = MOD, x = 0, y = 1;",
      "        for (v_t r = v; r != 0; ) {",
      "            v_t q = g / r;",
      "            g %= r; std::swap(g, r);",
      "            x -= q * y; std::swap(x, y);",
      "        }",
      "",
      "        assert(g == 1);",
      "        assert(y == MOD || y == -MOD);",
      "        return x < 0 ? x + MOD : x;",
      "    }",
      "    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }",
      "    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }",
      "",
      "    static constexpr v_t totient() {",
      "        v_t tot = MOD, tmp = MOD;",
      "        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {",
      "            tot = tot / p * (p - 1);",
      "            while (tmp % p == 0) tmp /= p;",
      "        }",
      "        if (tmp > 1) tot = tot / tmp * (tmp - 1);",
      "        return tot;",
      "    }",
      "",
      "    static v_t primitive_root() {",
      "        if (MOD == 1) return 0;",
      "        if (MOD == 2) return 1;",
      "",
      "        v_t tot = totient(), tmp = tot;",
      "        std::vector<int> tot_pr;",
      "        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {",
      "            tot_pr.push_back(p);",
      "            while (tmp % p == 0) tmp /= p;",
      "        }",
      "        if (tmp > 1) tot_pr.push_back(tmp);",
      "",
      "        for (v_t r = 2; r < MOD; r++) if (std::gcd(r, MOD) == 1) {",
      "            bool root = true;",
      "            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;",
      "            if (root) return r;",
      "        }",
      "        assert(false);",
      "    }",
      "",
      "    static modnum generator() { static modnum g = primitive_root(); return g; }",
      "    static v_t discrete_log(modnum v) {",
      "        static const v_t M = ceil(std::sqrt(MOD));",
      "        static std::unordered_map<v_t, v_t> table;",
      "        if (table.empty()) {",
      "            modnum e = 1;",
      "            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }",
      "        }",
      "        static modnum f = generator().pow(totient() - M);",
      "",
      "        for (v_t i = 0; i < M; i++) {",
      "            if (table.count(v.v)) return table[v.v] + i * M;",
      "            v *= f;",
      "        }",
      "        assert(false);",
      "    }",
      "",
      "    static modnum unity_root(int deg) {",
      "        assert(totient() % deg == 0);",
      "        return generator().pow(totient() / deg);",
      "    }",
      "",
      "    static modnum unity_root(int deg, int pow) {",
      "        static std::vector<modnum> table{ 0, 1 };",
      "        while (int(table.size()) <= deg) {",
      "            modnum w = unity_root(int(table.size()));",
      "            for (int s = int(table.size()), i = s / 2; i < s; i++) {",
      "                table.push_back(table[i]);",
      "                table.push_back(table[i] * w);",
      "            }",
      "        }",
      "        return table[deg + (pow < 0 ? deg + pow : pow)];",
      "    }",
      "",
      "    static modnum factorial(int n) {",
      "        static std::vector<modnum> fact = {1};",
      "        assert(n >= 0);",
      "        if (int(fact.size()) <= n) {",
      "            int had = fact.size();",
      "            fact.resize(n + 1);",
      "            for (int i = had; i <= n; i++) fact[i] = fact[i-1] * i;",
      "        }",
      "        return fact[n];",
      "    }",
      "    static modnum inverse_factorial(int n) {",
      "        static std::vector<modnum> finv = {1};",
      "        assert(n >= 0);",
      "        if (int(finv.size()) <= n) {",
      "            int had = finv.size();",
      "            finv.resz(n + 1), finv[n] = factorial(n).inv();",
      "            for (int i = n - 1; i >= had; i--) finv[i] = finv[i+1] * (i+1);",
      "        }",
      "        return finv[n];",
      "    }",
      "",
      "    static modnum small_inv(int n) {",
      "        assert(n > 0); return factorial(n - 1) * inverse_factorial(n);",
      "    }",
      "",
      "    static modnum ncr(int n, int r) {",
      "        if (r < 0 || n < r) return 0;",
      "        return factorial(n) * inverse_factorial(r) * inverse_factorial(n - r);",
      "    }",
      "};"
    ],
    "description": "modnum"
  },
  "garner": {
    "prefix": "garner",
    "body": [
      "/*",
      " * Garner's algorithm: finds the unique v modulo prod(MODS)",
      " * such that v is congruent to n[i] modulo MODS[i] for all i.",
      " * Elements of MODS should be pairwise co-prime.",
      " */",
      "",
      "template<typename V> V crt(const vector<V> MODS, const vector<V> n) {",
      "    auto inverse = [](V M, V n) {",
      "        V g = M, x = 0, y = 1;",
      "        for (V r = n; r != 0; ) {",
      "            V q = g / r;",
      "            g %= r; swap(g, r);",
      "            x -= q * y; swap(x, y);",
      "        }",
      "",
      "        assert(g == 1);",
      "        assert(y == M || y == -M);",
      "        return x < 0 ? x + M : x;",
      "    };",
      "",
      "    const int M = sz(MODS);",
      "",
      "    vector<V> x(M);",
      "    for (int i = 0; i < M; i++) {",
      "        x[i] = n[i];",
      "        for (int j = 0; j < i; j++) {",
      "            x[i] = V(x[i] - x[j]) * inverse(MODS[i], MODS[j] % MODS[i]) % MODS[i];",
      "            if (x[i] < 0) x[i] += MODS[i];",
      "        }",
      "    }",
      "",
      "    V v = 0;",
      "    for (int i = M - 1; i >= 0; i--)",
      "        v = MODS[i] * v + x[i];",
      "    return v;",
      "}"
    ],
    "description": "garner"
  },
  "tonelli-shanks": {
    "prefix": "tonelli-shanks",
    "body": [
      "#include <cassert>",
      "#include <cstdint>",
      "",
      "int product(int x, int y, int MOD) {",
      "    return int(int64_t(x) * y % MOD);",
      "}",
      "",
      "int mod_pow(int x, int k, int MOD) {",
      "    if (!k) return 1;",
      "    if (k&1) return product(x, mod_pow(x, k - 1, MOD), MOD);",
      "    return mod_pow(product(x, x, MOD), k / 2, MOD);",
      "}",
      "",
      "/*",
      " * Tonelli\u2013Shanks algorithm: finds some r such that r*r = n (MOD).",
      " * MOD should be a prime power.",
      " * Returns -1 if no such r exists.",
      " */",
      "int sqrt(int n, int MOD) {",
      "    assert(0 <= n && n < MOD);",
      "",
      "    if (n == 0) return 0;",
      "    if (MOD == 2) return n;",
      "    if (mod_pow(n, (MOD - 1) >> 1, MOD) != 1) return -1;",
      "",
      "    int Q = MOD - 1, S = 0;",
      "    while (!(Q&1)) Q >>= 1, S++;",
      "",
      "    int z = 2;",
      "    while (mod_pow(z, (MOD - 1) >> 1, MOD) == 1) z++;",
      "    z = mod_pow(z, Q, MOD);",
      "    assert(mod_pow(z, 1 << (S - 1), MOD) == MOD - 1);",
      "",
      "    int r = mod_pow(n, (Q + 1) >> 1, MOD),",
      "        t = mod_pow(n, Q, MOD);",
      "",
      "    for (int m = S - 2; t != 1; m--) {",
      "        int nz = product(z, z, MOD);",
      "        if (mod_pow(t, 1 << m, MOD) != 1) {",
      "            r = product(r, z,  MOD);",
      "            t = product(t, nz, MOD);",
      "        }",
      "        z = nz;",
      "    }",
      "",
      "    assert(product(r, r, MOD) == n);",
      "    return r;",
      "}"
    ],
    "description": "tonelli-shanks"
  },
  "point": {
    "prefix": "point",
    "body": [
      "#include <iostream>",
      "#include <vector>",
      "",
      "template<typename T>",
      "struct point {",
      "    T x, y;",
      "    point() : x(0), y(0) {}",
      "    point(T _x, T _y) : x(_x), y(_y) {}",
      "    friend std::istream& operator >> (std::istream& i, point& p) { return i >> p.x >> p.y; }",
      "    friend std::ostream& operator << (std::ostream& o, const point& p) {",
      "        return o << \"(\" << p.x << \", \" << p.y << \")\";",
      "    }",
      "",
      "    T norm() const { return x * x + y * y; }",
      "    double len() const { return sqrt(norm()); }",
      "    double ang() const { return atan2(y, x); }",
      "    point<T> conj() const { return { x, -y }; }",
      "",
      "    point& operator += (const point& o) { x += o.x; y += o.y; return *this; }",
      "    point& operator -= (const point& o) { x -= o.x; y -= o.y; return *this; }",
      "    point& operator *= (const T& c) { x *= c; y *= c; return *this; }",
      "    point& operator /= (const T& c) { x /= c; y /= c; return *this; }",
      "    friend point operator + (const point& a, const point& b) { return point(a) += b; }",
      "    friend point operator - (const point& a, const point& b) { return point(a) -= b; }",
      "    friend point operator * (const point& a, const T& c) { return point(a) *= c; }",
      "    friend point operator * (const T& c, const point& a) { return point(a) *= c; }",
      "    friend point operator / (const point& a, const T& c) { return point(a) /= c; }",
      "",
      "    bool operator == (const point& o) const { return x == o.x && y == o.y; }",
      "    bool operator != (const point& o) const { return x != o.x || y != o.y; }",
      "    bool operator < (const point& o) const { return (x != o.x) ? x < o.x : y < o.y; }",
      "    bool operator > (const point& o) const { return (x != o.x) ? x > o.x : y > o.y; }",
      "    bool operator <= (const point& o) const { return !(*this > o); }",
      "",
      "    friend T dot(const point& a, const point& b) { return a.x * b.x + a.y * b.y; }",
      "    friend T cross(const point& a, const point& b) { return a.x * b.y - a.y * b.x; }",
      "    friend T cross(const point& p, const point& a, const point& b) { return cross(a - p, b - p); }",
      "",
      "    friend point<T> operator * (const point& a, const point& b) {",
      "        return { a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x };",
      "    }",
      "    friend point<T> operator / (const point& a, const point& b) {",
      "        return a * b.conj() / b.norm();",
      "    }",
      "",
      "    point dir() const { return point(*this) / len(); }",
      "    point rotate(const double& ang) const { return *this * point(cos(ang), sin(ang)); }",
      "",
      "    double dist(const point& a) const { return (a - *this).len(); }",
      "    double dist(const point& a, const point& b) {",
      "        return abs(cross(*this, a, b)) / a.dist(b);",
      "    }",
      "    point reflect(const point& a, const point& b) const {",
      "        return a + ((*this - a) / (b - a)).conj() * (b - a);",
      "    }",
      "    point foot(const point& a, const point& b) const {",
      "        return (*this + this->reflect(a, b)) / 2;",
      "    }",
      "    friend point extension(const point& a, const point& b, const point& c, const point& d) {",
      "        T u = cross(a, b, c), v = cross(a, b, d);",
      "        return (d * u - c * v) / (u - v);",
      "    }",
      "",
      "    using polygon = std::vector<point<T>>;",
      "",
      "    friend polygon seg_intersect(point a, point b, point c, point d) {",
      "        if (a > b) swap(a, b);",
      "        if (c > d) swap(c, d);",
      "",
      "        T a1 = cross(a, b, c), a2 = cross(a, b, d);",
      "        if (a1 > a2) swap(a1, a2);",
      "        if (!(a1 <= 0 && a2 >= 0)) return {};",
      "",
      "        if (a1 == 0 && a2 == 0) {",
      "            if (cross(a, c, d) != 0) return {};",
      "            point<T> x1 = max(a, c), x2 = min(b, d);",
      "            if (x1 > x2) return {};",
      "            if (x1 == x2) return { x1 };",
      "            return { x1, x2 };",
      "        }",
      "",
      "        point<T> z = extension(a, b, c, d);",
      "        if (a <= z && z <= b) return { z };",
      "        return {};",
      "    }",
      "",
      "    friend std::ostream& operator << (std::ostream& o, const polygon& poly) {",
      "        o << \"{\";",
      "        for (auto pt : poly) o << \" \" << pt;",
      "        return o << \" }\";",
      "    }",
      "",
      "    enum class Classification { in, out, on };",
      "    Classification classify(const polygon& p) const {",
      "        bool ans = 0;",
      "        for (int i = 0; i < int(p.size()); i++) {",
      "            point<T> a = p[i], b = p[(i + 1) % p.size()];",
      "            if (cross(a, b, *this) == 0 && min(a, b) <= *this && *this <= max(a, b))",
      "                return Classification::on;",
      "            if (a.y > b.y) swap(a, b);",
      "            if (a.y <= y && y < b.y && cross(*this, a, b) > 0) ans ^= 1;",
      "        }",
      "        return ans ? Classification::in : Classification::out;",
      "    }",
      "",
      "    friend polygon convex_hull(const std::vector<point>& pts) {",
      "        point pivot = *min_element(all(pts));",
      "        auto sorted = pts;",
      "        sort(all(sorted), [&pivot](const point& p, const point& q) {",
      "            T cp = cross(pivot, p, q);",
      "            if (cp != 0) return cp > 0;",
      "            return pivot.dist(p) < pivot.dist(q);",
      "        });",
      "",
      "        int j = 0;",
      "        polygon res(pts.size());",
      "        for (const point& p : sorted) {",
      "            while (j > 1 && cross(res[j - 2], res[j - 1], p) <= 0)",
      "                j--;",
      "            res[j++] = p;",
      "        }",
      "        res.erase(res.begin() + j, res.end());",
      "        return res;",
      "    }",
      "",
      "    // twice the signed area",
      "    friend T area(const polygon& p) {",
      "        T a = 0;",
      "        for (int i = 0; i < int(p.size()); i++)",
      "            a += cross(p[i], p[i+1 < sz(p) ? i+1 : 0]);",
      "        return a;",
      "    }",
      "",
      "    // sorts CCW for vectors in the same half-plane",
      "    template <typename U> static int sign(const U &v) { return (v > 0) - (v < 0); }",
      "    friend int compare_by_angle(const point &a, const point &b) { return sign(cross(b, a)); }",
      "    friend int compare_by_angle(const point &a, const point &b, const point &origin) { return sign(cross(origin, b, a)); }",
      "",
      "    // sorts by angle CCW from the positive x-axis",
      "    template <typename I> friend void sort_by_angle(I first, I last, const point<T> &origin = point<T>{}) {",
      "        first = partition(first, last, [&](const point<T> &p) { return p == origin; });",
      "        auto pivot = partition(first, last, [&](const point<T> &p) { return p > origin; });",
      "        auto compare = [&](const point<T> &l, const point<T> &r) { return compare_by_angle(l, r, origin) < 0; };",
      "        sort(first, pivot, compare);",
      "        sort(pivot, last, compare);",
      "    }",
      "};"
    ],
    "description": "point"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "enum DIVISOR_TYPE { ALL, SQUARE_FREE };",
      "template<int MAXV> struct sieve {",
      "    vi primes;",
      "    struct num {",
      "        int  least_prime;       // least prime divisor",
      "        int  div_least_prime;   // num divided by least_prime",
      "        char lp_multiplicity;   // multiplicity of the least prime divisor",
      "        char mu;                // mobius function",
      "        int  phi;               // euler's totient function",
      "",
      "        static num ONE() { return { INT_MAX, 1, 0, 1, 1}; }",
      "",
      "        num prod(int my_value, int p) const {",
      "            if (p < least_prime)",
      "                return { p, my_value, 1, char(-mu), phi * (p - 1) };",
      "            assert(p == least_prime);",
      "            return { p, my_value, char(lp_multiplicity + 1), 0, phi * p };",
      "        }",
      "    };",
      "    vector<num> nums;",
      "    const num& operator[](int i){ return nums[i]; }",
      "",
      "    sieve() : nums(MAXV) {",
      "        nums[1] = num::ONE();",
      "        for (int v = 2; v < MAXV; v++) {",
      "            num& n = nums[v];",
      "            if (!n.least_prime) {",
      "                n = nums[1].prod(1, v);",
      "                primes.pb(v);",
      "            }",
      "            for (int p : primes) {",
      "                if (p > n.least_prime || v * p >= MAXV) break;",
      "                nums[v * p] = n.prod(v, p);",
      "            }",
      "        }",
      "    }",
      "",
      "    bool is_prime(int v) const {",
      "        assert(0 < v && v < MAXV);",
      "        return nums[v].least_prime == v;",
      "    }",
      "",
      "    int eliminate_least_prime(int v) const {",
      "        assert(1 < v && v < MAXV);",
      "        for (int m = nums[v].lp_multiplicity; m > 0; m--)",
      "            v = nums[v].div_least_prime;",
      "        return v;",
      "    }",
      "",
      "    const vpii& factor(int v) const {",
      "        assert(0 < v && v < MAXV);",
      "        static vpii res; res.clear();",
      "        for (; v > 1; v = eliminate_least_prime(v))",
      "            res.emplace_back(nums[v].least_prime, nums[v].lp_multiplicity);",
      "        reverse(all(res));",
      "        return res;",
      "    }",
      "",
      "    template<typename F> void for_each_divisor_unordered(int v, F f,",
      "            DIVISOR_TYPE t = ALL, int d = 1) const {",
      "        assert(0 < v && v < MAXV);",
      "        if (v == 1) { f(d); return; }",
      "        int w = eliminate_least_prime(v);",
      "        char M = min(nums[v].lp_multiplicity, char(t == ALL ? CHAR_MAX : 1));",
      "        for (int m = 0; m <= M; m++, d *= nums[v].least_prime) {",
      "            for_each_divisor_unordered(w, f, t, d);",
      "        }",
      "    }",
      "",
      "    const vi& unordered_divisors(int v, DIVISOR_TYPE t = ALL) const {",
      "        assert(0 < v && v < MAXV);",
      "        static vi res; res.clear();",
      "        for_each_divisor_unordered(v, [&](int d) { res.pb(d); }, t);",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "sieve"
  },
  "bitwise_convolution": {
    "prefix": "bitwise_convolution",
    "body": [
      "namespace bitwise_convolution {",
      "    template<typename T, bool INV> void transform(vector<T>& v, int N, array<int, 4> t) {",
      "        assert(__builtin_popcount(N) == 1);",
      "        for (int c : t) assert(abs(c) <= 1);",
      "        int w = t[0], x = t[1], y = t[2], z = t[3];",
      "        if (INV) swap(w, z), x *= -1, y *= -1;",
      "",
      "        auto prod = [](int c, T v){ return c > 0 ? v : c < 0 ? -v : 0; };",
      "        for (int l = 1; l < N; l <<= 1) {",
      "            for (int i = 0; i < N; i += l << 1) {",
      "                for (int j = 0; j < l; j++) {",
      "                    T a = v[i + j];",
      "                    T b = v[i + j + l];",
      "                    v[i + j] = prod(w, a) + prod(x, b);",
      "                    v[i + j + l] = prod(y, a) + prod(z, b);",
      "                }",
      "            }",
      "        }",
      "        if (INV) {",
      "            const T dinv = 1 / T{w * z - x * y}.pow(__builtin_ctz(N));",
      "            for (int i = 0; i < N; i++) v[i] *= dinv;",
      "        }",
      "    }",
      "",
      "    constexpr array<int, 4>  OR(){ return {1,0,1,1}; }",
      "    constexpr array<int, 4> AND(){ return {0,1,1,1}; }",
      "    constexpr array<int, 4> XOR(){ return {1,1,1,-1}; }",
      "",
      "    template<typename T>",
      "    vector<T> conv(const vector<T>& a, const vector<T>& b, array<int, 4> t) {",
      "        if (a.empty() || b.empty()) return {};",
      "        int N = 1 << (32 - __builtin_clz(max(sz(a), sz(b)) - 1));",
      "        static vector<T> fa, fb;",
      "        if (N > sz(fa)) fa.resize(N), fb.resize(N);",
      "",
      "        copy(all(a), fa.begin());",
      "        fill(fa.begin() + sz(a), fa.begin() + N, 0);",
      "        copy(all(b), fb.begin());",
      "        fill(fb.begin() + sz(b), fb.begin() + N, 0);",
      "",
      "        transform<T, false>(fa, N, t);",
      "        transform<T, false>(fb, N, t);",
      "        for (int i = 0; i < N; i++) fa[i] = fa[i] * fb[i];",
      "        transform<T, true>(fa, N, t);",
      "        return { fa.begin(), fa.begin() + N };",
      "    }",
      "}"
    ],
    "description": "bitwise_convolution"
  },
  "bignum_addpow2_compare": {
    "prefix": "bignum_addpow2_compare",
    "body": [
      "// {{{ strings/polynomial_hash }}}",
      "",
      "#include <vector>",
      "#include <cassert>",
      "#include <iostream>",
      "",
      "struct bignum_addpow2_compare {",
      "    using hash_t = polynomial_hash<modnum<int(1e9 + 7)>, 3, 2>;",
      "",
      "    struct binary_string {",
      "        hash_t hash;",
      "        int ct_trailing_ones;",
      "        int left, right;",
      "",
      "        binary_string(bool bit) : hash(bit), ct_trailing_ones(bit), left(-1), right(-1) {}",
      "",
      "        binary_string(hash_t _hash, int _ct_trailing_ones, int _left, int _right)",
      "            : hash(_hash), ct_trailing_ones(_ct_trailing_ones), left(_left), right(_right) {}",
      "",
      "        int length() const { return hash.N; }",
      "        bool is_all_ones() const { return hash.N == ct_trailing_ones; }",
      "    };",
      "",
      "    std::vector<binary_string> nums = { binary_string(0), binary_string(1) };",
      "",
      "    const int one = 1;",
      "    std::vector<int> zero = { 0 };",
      "",
      "    int concatenate(int x, int y) {",
      "        nums.emplace_back(",
      "            hash_t::concatenate(nums[x].hash, nums[y].hash),",
      "            nums[y].ct_trailing_ones + (nums[y].is_all_ones() ? nums[x].ct_trailing_ones : 0),",
      "            x,",
      "            y",
      "        );",
      "        return int(nums.size()) - 1;",
      "    }",
      "",
      "    int get_zero_of_width(int bit_width) {",
      "        int index = __builtin_ctz(bit_width);",
      "        while (index >= int(zero.size()))",
      "            zero.push_back(concatenate(zero.back(), zero.back()));",
      "        return zero[index];",
      "    }",
      "",
      "    int carry_count(int x, int pow) const {",
      "        const int len = nums[x].length();",
      "",
      "        if (len <= pow)",
      "            return 0;",
      "",
      "        if (nums[x].is_all_ones())",
      "            return len - pow;",
      "",
      "        if (len == 1)",
      "            return nums[x].ct_trailing_ones;",
      "",
      "        int res = carry_count(nums[x].right, pow);",
      "",
      "        if (pow + res >= len / 2)",
      "            res += carry_count(nums[x].left, pow + res - len / 2);",
      "",
      "        return res;",
      "    }",
      "",
      "    int invert_range(int x, int L, int R) {",
      "        const int len = nums[x].length();",
      "        assert(0 <= L && L < R && R <= len);",
      "",
      "        if (len == 1)",
      "            return x ^ 1;",
      "",
      "        if (0 == L && R == len && nums[x].is_all_ones())",
      "            return get_zero_of_width(len);",
      "",
      "        int right = L < len / 2 ? invert_range(nums[x].right, L, std::min(R, len / 2)) : nums[x].right;",
      "        int left  = R > len / 2 ? invert_range(nums[x].left, std::max(0, L - len / 2), R - len / 2) : nums[x].left;",
      "",
      "        return concatenate(left, right);",
      "    }",
      "",
      "    int add_pow2(int x, int pow) {",
      "        int carries = carry_count(x, pow);",
      "        while (nums[x].length() <= pow + carries)",
      "            x = concatenate(get_zero_of_width(nums[x].length()), x);",
      "        return invert_range(x, pow, pow + carries + 1);",
      "    }",
      "",
      "    bool less_than(int x, int y) const {",
      "        if (nums[x].length() != nums[y].length())",
      "            return nums[x].length() < nums[y].length();",
      "",
      "        if (nums[x].length() == 1)",
      "            return nums[x].ct_trailing_ones < nums[y].ct_trailing_ones;",
      "",
      "        if (nums[nums[x].left].hash == nums[nums[y].left].hash)",
      "            return less_than(nums[x].right, nums[y].right);",
      "",
      "        return less_than(nums[x].left, nums[y].left);",
      "    }",
      "",
      "    void print_bits(int x) const {",
      "        if (nums[x].length() == 1) {",
      "            std::cout << nums[x].ct_trailing_ones;",
      "        } else {",
      "            print_bits(nums[x].left);",
      "            print_bits(nums[x].right);",
      "        }",
      "    }",
      "};"
    ],
    "description": "bignum_addpow2_compare"
  },
  "karatsuba": {
    "prefix": "karatsuba",
    "body": [
      "// Naive O(AB) multiplication of polynomials a and b",
      "template<typename T>",
      "T* naive_product(T* c, const T* ai, const T* aj, const T* bi, const T* bj) {",
      "    T* ce = c + (aj - ai) + (bj - bi) - 1;",
      "    fill(c, ce, T{});",
      "    for (auto a = ai; a < aj; a++)",
      "        for (auto b = bi; b < bj; b++)",
      "            c[a - ai + b - bi] += *a * *b;",
      "    return ce;",
      "}",
      "",
      "template<typename T>",
      "vector<T> naive_product(const vector<T>& a, const vector<T>& b) {",
      "    vector<T> c(sz(a) + sz(b) - 1);",
      "    naive_product(c.data(), a.data(), a.data() + sz(a), b.data(), b.data() + sz(b));",
      "    return c;",
      "}",
      "",
      "template<typename T> T get(T* i, T* j, int k) {",
      "    return i + k < j ? *(i + k) : T{};",
      "}",
      "",
      "// O(max(A, B)^log_2(3)) multiplication of polynomials a and b",
      "template<typename T, int SZ>",
      "T* karatsuba(T* c, const T* ai, const T* aj, const T* bi, const T* bj) {",
      "    if (ai >= aj || bi >= bj) return c;",
      "    if (aj - ai < SZ) return naive_product(c, ai, aj, bi, bj);",
      "    assert(aj - ai >= bj - bi);",
      "",
      "    const int N = aj - ai + bj - bi - 1;",
      "    const int M = (aj - ai + 1) / 2;",
      "    const int S = max(N, 3 * M);",
      "",
      "    for (int i = 0; i < M; i++) {",
      "        c[0 + i]      =  get(ai, aj, i) + get(ai, aj, M + i);",
      "        c[5 * M + i]  =  get(bi, bj, i) + get(bi, bj, M + i);",
      "    }",
      "    karatsuba<T, SZ>(c + M, c, c + M, c + 5 * M, c + 6 * M);",
      "    c[3 * M - 1] = T{};",
      "",
      "    T* ce = karatsuba<T, SZ>(c + S, ai, ai + M, bi, min(bi + M, bj));",
      "    for (int i = 0; i < N; i++) {",
      "        if      (i < M)         c[i]  = get(c + S, ce, i);",
      "        else if (i < 2 * M)     c[i] += get(c + S, ce, i) - get(c + S, ce, i - M);",
      "        else                    c[i] -= get(c + S, ce, i - M);",
      "    }",
      "",
      "    ce = karatsuba<T, SZ>(c + S, ai + M, aj, bi + M, bj);",
      "    for (int i = M; i < N; i++) {",
      "        if      (i < 2 * M)     c[i] -= get(c + S, ce, i - M);",
      "        else if (i < 3 * M)     c[i] += get(c + S, ce, i - 2 * M) - get(c + S, ce, i - M);",
      "        else                    c[i]  = get(c + S, ce, i - 2 * M);",
      "    }",
      "",
      "    return c + N;",
      "}",
      "",
      "template<typename T, int SZ = 8>",
      "vector<T> karatsuba(const vector<T>& _a, const vector<T>& _b) {",
      "    auto& a = sz(_a) > sz(_b) ? _a : _b, b = sz(_a) > sz(_b) ? _b : _a;",
      "    if (sz(a) < SZ) return naive_product(a, b);",
      "    vector<T> c(4 * (sz(a) + 1));",
      "    karatsuba<T, SZ>(c.data(), a.data(), a.data() + sz(a), b.data(), b.data() + sz(b));",
      "    c.erase(c.begin() + sz(a) + sz(b) - 1, c.end());",
      "    return c;",
      "}"
    ],
    "description": "karatsuba"
  },
  "count_distinct_in_range": {
    "prefix": "count_distinct_in_range",
    "body": [
      "// {{{ data_structures/segment_tree_persistent.cpp }}}",
      "",
      "#include <functional>",
      "#include <vector>",
      "#include <algorithm>",
      "#include <cassert>",
      "",
      "template<typename T>",
      "struct count_distinct_in_range {",
      "    segment_tree_persistent<int, std::plus<int>> st;",
      "",
      "    template<typename InputIterator>",
      "    count_distinct_in_range(InputIterator first, InputIterator last, int copies_allowed = 1) {",
      "        assert(copies_allowed >= 1);",
      "",
      "        std::vector<std::remove_reference_t<decltype(*first)>> universe(first, last);",
      "        std::sort(universe.begin(), universe.end());",
      "        universe.erase(std::unique(universe.begin(), universe.end()), universe.end());",
      "",
      "        std::vector<std::vector<int>> occurrences(universe.size());",
      "",
      "        int SZ = 0;",
      "        for (InputIterator iter = first; iter != last; iter++) {",
      "            int val = int(lower_bound(universe.begin(), universe.end(), *iter) - universe.begin());",
      "            occurrences[val].push_back(SZ);",
      "            SZ++;",
      "        }",
      "",
      "        st = decltype(st)(SZ, 0, std::plus<int>());",
      "",
      "        std::vector<int> successor(SZ, -1);",
      "",
      "        for (int i = 0; i < universe.size(); i++) {",
      "            for (int j = 0; j < std::min(copies_allowed, int(occurrences[i].size())); j++)",
      "                st.assign(occurrences[i][j], 1, -1);",
      "",
      "            for (int j = 0; j + copies_allowed < int(occurrences[i].size()); j++)",
      "                successor[occurrences[i][j]] = occurrences[i][j + copies_allowed];",
      "        }",
      "",
      "        for (int i = 0; i < SZ; i++)",
      "            if (successor[i] != -1)",
      "                st.assign(successor[i], 1, i);",
      "    }",
      "",
      "    /* Returns the number of elements at indices in [first, last) counting only",
      "     * the first 'copies_allowed' appearances of each distinct value.",
      "     */",
      "    int get_count(int first, int last) {",
      "        return st.accumulate(first, last, first);",
      "    }",
      "};"
    ],
    "description": "count_distinct_in_range"
  },
  "subset_sum": {
    "prefix": "subset_sum",
    "body": [
      "#include <bitset>",
      "#include <vector>",
      "#include <cassert>",
      "",
      "/* Accepts a collection of integers with sum at most MAX_SUM.",
      " * Computes its set of subset sums in O(MAX_SUM * sqrt(sum) / MACHINE_WORD_SIZE)",
      " */",
      "template<int MAX_SUM, typename InputIterator>",
      "std::bitset<MAX_SUM + 1> subset_sum(InputIterator first, InputIterator last) {",
      "    int sum = accumulate(first, last, 0);",
      "    assert(sum <= MAX_SUM);",
      "",
      "    static std::vector<int> count(MAX_SUM + 1);",
      "",
      "    for (InputIterator iter = first; iter != last; iter++)",
      "        count[*iter]++;",
      "",
      "    std::bitset<MAX_SUM + 1> result;",
      "    result[0] = 1;",
      "",
      "    for (int val = 1; val <= sum; val++) {",
      "        if (count[val] > 2) {",
      "            int pairs = (count[val] - 1) / 2;",
      "            count[2 * val] += pairs;",
      "            count[val] -= 2 * pairs;",
      "        }",
      "",
      "        while (count[val]) {",
      "            result |= result << val;",
      "            count[val]--;",
      "        }",
      "    }",
      "",
      "    return result;",
      "}"
    ],
    "description": "subset_sum"
  },
  "stable_counting_sort": {
    "prefix": "stable_counting_sort",
    "body": [
      "#include <vector>",
      "#include <numeric>",
      "#include <algorithm>",
      "",
      "namespace stable_counting_sort {",
      "    template<typename T = int>",
      "    T identity(const T& t) { return t; }",
      "",
      "    template<typename T_extract_key = int(*)(const int&)>",
      "    const std::vector<int>& permutation(int SZ, int MAX_KEY,",
      "            const T_extract_key &extract_key = identity) {",
      "",
      "        static std::vector<int> p;",
      "        p.resize(SZ);",
      "",
      "        if (SZ < 256) {",
      "            std::iota(p.begin(), p.end(), 0);",
      "            std::sort(p.begin(), p.end(), [&](int a, int b) {",
      "                return extract_key(a) < extract_key(b);",
      "            });",
      "        } else {",
      "            static std::vector<int> count;",
      "            count.assign(MAX_KEY, 0);",
      "            for (int i = 0; i < SZ; i++)",
      "                count[extract_key(i)]++;",
      "            for (int i = 0; i < MAX_KEY - 1; i++)",
      "                count[i + 1] += count[i];",
      "            for (int i = SZ - 1; i >= 0; i--)",
      "                p[--count[extract_key(i)]] = i;",
      "        }",
      "",
      "        return p;",
      "    }",
      "}"
    ],
    "description": "stable_counting_sort"
  },
  "sparse_table": {
    "prefix": "sparse_table",
    "body": [
      "#include <vector>",
      "#include <cassert>",
      "",
      "template<typename T, typename IdempotentBinaryOperation = const T&(*)(const T&, const T&)>",
      "struct sparse_table {",
      "    int SZ;",
      "    IdempotentBinaryOperation TT;",
      "    std::vector<std::vector<T>> data;",
      "",
      "    sparse_table() {}",
      "",
      "    sparse_table(IdempotentBinaryOperation _TT) : TT(_TT) {}",
      "",
      "    template<typename Function>",
      "    sparse_table(int _SZ, IdempotentBinaryOperation _TT, Function fn) : TT(_TT) {",
      "        construct(_SZ, fn);",
      "    }",
      "",
      "    template<typename Function>",
      "    void construct(int _SZ, Function fn) {",
      "        SZ = _SZ;",
      "",
      "        const int L = 32 - __builtin_clz(std::max(SZ - 1, 1));",
      "        data.assign(L, std::vector<T>(SZ));",
      "",
      "        for (int i = 0; i < SZ; i++)",
      "            data[0][i] = fn(i);",
      "",
      "        for (int l = 0; l + 1 < L; l++)",
      "            for (int i = 0; i + (2 << l) <= SZ; i++)",
      "                data[l + 1][i] = TT(data[l][i], data[l][i + (1 << l)]);",
      "    }",
      "",
      "    // Accumulates the elements at indices in [i, j) in O(1)",
      "    T accumulate(int first, int last) const {",
      "        assert(0 <= first && first < last && last <= SZ);",
      "        int l = last - first > 1 ? 31 - __builtin_clz(last - first - 1) : 0;",
      "        return TT(data[l][first], data[l][last - (1 << l)]);",
      "    }",
      "};"
    ],
    "description": "sparse_table"
  },
  "segment_tree_persistent": {
    "prefix": "segment_tree_persistent",
    "body": [
      "#include <vector>",
      "#include <limits>",
      "#include <cassert>",
      "#include <algorithm>",
      "",
      "template<typename T, typename AssociativeOperation, typename Timestamp = int>",
      "struct segment_tree_persistent {",
      "    struct node {",
      "        T v;",
      "        int left, right;",
      "    };",
      "    struct snapshot {",
      "        Timestamp t;",
      "        int root;",
      "        int data_size;",
      "        bool operator < (const snapshot &o) const { return t < o.t; }",
      "    };",
      "",
      "    int SZ;",
      "    T identity;",
      "    AssociativeOperation TT;",
      "    std::vector<node> data;",
      "    std::vector<snapshot> history;",
      "",
      "    segment_tree_persistent() {}",
      "",
      "    segment_tree_persistent(int _SZ, T _identity, AssociativeOperation _TT) : identity(_identity), TT(_TT) {",
      "        SZ = 1 << (32 - __builtin_clz(_SZ - 1));",
      "        assert(SZ >= _SZ && __builtin_popcount(SZ) == 1);",
      "",
      "        data.push_back({ identity, -1, -1 });",
      "        for (int loc = 1; loc <= __builtin_ctz(SZ); loc++)",
      "            data.push_back({ TT(data[loc - 1].v, data[loc - 1].v), loc - 1, loc - 1 });",
      "",
      "        history.push_back({ std::numeric_limits<Timestamp>::min(), int(data.size()) - 1, int(data.size()) });",
      "    }",
      "",
      "private:",
      "    int modify_leaf(int i, T v, int loc, int L, int R, int immutable, bool overwrite) {",
      "        node updated;",
      "        if (R - L == 1) {",
      "            updated = { overwrite ? v : TT(data[loc].v, v), -1, -1 };",
      "        } else {",
      "            int M = L + (R - L) / 2;",
      "            int left  = i <  M ? modify_leaf(i, v, data[loc].left,  L, M, immutable, overwrite) : data[loc].left;",
      "            int right = M <= i ? modify_leaf(i, v, data[loc].right, M, R, immutable, overwrite) : data[loc].right;",
      "            updated = { TT(data[left].v, data[right].v), left, right };",
      "        }",
      "        if (loc < immutable) {",
      "            loc = int(data.size());",
      "            data.push_back(updated);",
      "        } else {",
      "            data[loc] = updated;",
      "        }",
      "        return loc;",
      "    }",
      "",
      "    void modify_leaf(int i, T v, Timestamp t, bool overwrite) {",
      "        int current_root = history.back().root;",
      "        if (history.back().t == t) history.pop_back();",
      "",
      "        int immutable = history.back().data_size;",
      "        int updated_root = modify_leaf(i, v, current_root, 0, SZ, immutable, overwrite);",
      "        history.push_back({ t, updated_root, int(data.size()) });",
      "    }",
      "",
      "    T accumulate(int i, int j, T init, int loc, int L, int R) const {",
      "        if (L == i && j == R) {",
      "            init = TT(init, data[loc].v);",
      "        } else {",
      "            int M = L + (R - L) / 2;",
      "            if (i < M) init = accumulate(i, std::min(j, M), init, data[loc].left,  L, M);",
      "            if (M < j) init = accumulate(std::max(i, M), j, init, data[loc].right, M, R);",
      "        }",
      "        return init;",
      "    }",
      "",
      "public:",
      "    // Assigns v at index i during moment t",
      "    void assign(int i, T v, Timestamp t) {",
      "        assert(0 <= i && i < SZ && history.back().t <= t);",
      "        modify_leaf(i, v, t, true);",
      "    }",
      "",
      "    // Replaces the current value at index i with TT(current value, v) during moment t",
      "    void combine_and_assign(int i, T v, Timestamp t) {",
      "        assert(0 <= i && i < SZ && history.back().t <= t);",
      "        modify_leaf(i, v, t, false);",
      "    }",
      "",
      "    // Accumulates the elements at indices in [first, last) as they were before t (after all assignments with t' < t)",
      "    T accumulate(int first, int last, Timestamp t) const {",
      "        if (first >= last) return identity;",
      "        assert(0 <= first && last <= SZ);",
      "        int root_before_t = std::prev(std::lower_bound(history.begin(), history.end(), snapshot{ t, -1, -1 }))->root;",
      "        return accumulate(first, last, identity, root_before_t, 0, SZ);",
      "    }",
      "};"
    ],
    "description": "segment_tree_persistent"
  },
  "sqrt_decomposition_point_query": {
    "prefix": "sqrt_decomposition_point_query",
    "body": [
      "#include <vector>",
      "#include <cassert>",
      "",
      "template<typename T, typename CommutativeOperation>",
      "struct sqrt_decomposition_point_query {",
      "    int SZ;",
      "    T t_identity;",
      "    CommutativeOperation TT;",
      "",
      "    int SQRT;",
      "    std::vector<T> data;",
      "    std::vector<T> block_data;",
      "",
      "    sqrt_decomposition_point_query() {}",
      "",
      "    sqrt_decomposition_point_query(int _SZ, T _t_identity, CommutativeOperation _TT)",
      "            : SZ(_SZ), t_identity(_t_identity), TT(_TT) {",
      "        SQRT = 0;",
      "        while (SQRT * SQRT < SZ)",
      "            SQRT++;",
      "",
      "        data.assign(SZ, t_identity);",
      "        block_data.assign(SQRT, t_identity);",
      "    }",
      "",
      "    template<typename Function>",
      "    void assign(Function fn) {",
      "        for (int i = 0; i < SZ; i++)",
      "            data[i] = fn(i);",
      "    }",
      "",
      "public:",
      "    // Replaces the current value at index i with TT(current value, v)",
      "    void add(int i, T v) {",
      "        data[i] = TT(data[i], v);",
      "    }",
      "",
      "    void add_to_range(int first, int last, T v) {",
      "        if (last - first < SQRT) {",
      "            for (int i = first; i < last; i++)",
      "                data[i] = TT(data[i], v);",
      "            return;",
      "        }",
      "",
      "        const int first_block = (first + SQRT - 1) / SQRT;",
      "        const int last_block  = last / SQRT;",
      "",
      "        for (int i = first; i < first_block * SQRT; i++)",
      "            data[i] = TT(data[i], v);",
      "",
      "        for (int block = first_block; block < last_block; block++)",
      "            block_data[block] = TT(block_data[block], v);",
      "",
      "        for (int i = last_block * SQRT; i < last; i++)",
      "            data[i] = TT(data[i], v);",
      "    }",
      "",
      "    // Returns the current value at index i",
      "    T read(int i) const {",
      "        return TT(data[i], block_data[i / SQRT]);",
      "    }",
      "};"
    ],
    "description": "sqrt_decomposition_point_query"
  },
  "line": {
    "prefix": "line",
    "body": [
      "#include <functional>",
      "#include <limits>",
      "",
      "template<typename T, bool T_integral = std::is_integral<T>::value>",
      "struct line {",
      "    static constexpr T infinity = std::numeric_limits<T>::has_infinity ?",
      "        std::numeric_limits<T>::infinity() : std::numeric_limits<T>::max();",
      "",
      "    T a, b;",
      "    mutable T intersects_next = infinity;",
      "",
      "    T evaluate(T x) const {",
      "        return a * x + b;",
      "    }",
      "",
      "    static T div(const T &a, const T &b) {",
      "        if constexpr (T_integral)",
      "            return a / b - ((a ^ b) < 0 && (a % b));",
      "        else",
      "            return a / b;",
      "    }",
      "",
      "    T compute_intersection(const line<T> &o) const {",
      "        if (a == o.a) return b > o.b ? infinity : -infinity;",
      "        return div(o.b - b, a - o.a);",
      "    }",
      "};"
    ],
    "description": "line"
  },
  "binary_indexed_tree": {
    "prefix": "binary_indexed_tree",
    "body": [
      "#include <iterator>",
      "#include <vector>",
      "#include <cassert>",
      "#include <functional>",
      "",
      "template<typename T, typename AssociativeOperation>",
      "struct binary_indexed_tree {",
      "    int SZ;",
      "    T identity;",
      "    AssociativeOperation TT;",
      "    std::vector<T> data;",
      "",
      "    binary_indexed_tree() {}",
      "",
      "    binary_indexed_tree(int _SZ, T _identity, AssociativeOperation _TT)",
      "            : SZ(_SZ), identity(_identity), TT(_TT) {",
      "        data.assign(2 * SZ, identity);",
      "    }",
      "",
      "    // Replaces the current value at index i with TT(current value, v)",
      "    void add(int i, T v) {",
      "        for (i++; i <= SZ; i += i & -i)",
      "            data[i] = TT(data[i], v);",
      "    }",
      "",
      "    // Returns the result of accumulating the elements at indices in [0, len)",
      "    T accumulate_prefix(int len) const {",
      "        assert(0 <= len && len <= SZ);",
      "        T res = identity;",
      "        for (; len; len -= len & -len)",
      "            res = TT(res, data[len]);",
      "        return res;",
      "    }",
      "",
      "    /* Returns the smallest len in [0, S] such that p(accumulate_prefix(len)) returns true.",
      "     * Returns S + 1 if no such len exists.",
      "     * Requires that p(accumulate_prefix(len)) is non-decreasing in len.",
      "     */",
      "    template<typename Predicate>",
      "    int binary_search(Predicate p) const {",
      "        if (p(identity)) return 0;",
      "",
      "        int len = 0;",
      "        T accumulator = identity;",
      "",
      "        for (int bit = 31 - __builtin_clz(SZ); bit >= 0; bit--) {",
      "            int next = len + (1 << bit);",
      "            if (next > SZ) continue;",
      "",
      "            T combined = TT(accumulator, data[next]);",
      "            if (!p(combined)) {",
      "                len = next;",
      "                accumulator = combined;",
      "            }",
      "        }",
      "",
      "        return len + 1;",
      "    }",
      "};"
    ],
    "description": "binary_indexed_tree"
  },
  "line_container": {
    "prefix": "line_container",
    "body": [
      "// {{{ data_structures/line }}}",
      "",
      "#include <cassert>",
      "#include <set>",
      "",
      "bool compare_on_intersection = false;",
      "",
      "template<typename T>",
      "bool operator < (const line<T> &p, const line<T> &q) {",
      "    if (compare_on_intersection)",
      "        return p.intersects_next < q.intersects_next;",
      "",
      "    return p.a != q.a ? p.a < q.a : p.b < q.b;",
      "}",
      "",
      "template<typename T>",
      "struct line_container : std::set<line<T>> {",
      "    using typename std::set<line<T>>::iterator;",
      "",
      "    bool set_boundary(iterator left, iterator right) {",
      "        if (right == this->end()) {",
      "            left->intersects_next = line<T>::infinity;",
      "            return false;",
      "        }",
      "",
      "        left->intersects_next = left->compute_intersection(*right);",
      "        return left->intersects_next >= right->intersects_next;",
      "    }",
      "",
      "    bool is_never_maximal(iterator y) {",
      "        return y != this->begin() && set_boundary(prev(y), y);",
      "    }",
      "",
      "    // insert the line f(x) = a * x + b",
      "    void insert_line(T a, T b) {",
      "        auto [it, inserted] = this->insert({ a, b });",
      "",
      "        if (!inserted)",
      "            return;",
      "",
      "        while (set_boundary(it, next(it)))",
      "            this->erase(next(it));",
      "",
      "        if (is_never_maximal(it)) {",
      "            it = this->erase(it);",
      "            set_boundary(prev(it), it);",
      "        }",
      "",
      "        while (it != this->begin() && is_never_maximal(prev(it))) {",
      "            this->erase(prev(it));",
      "            set_boundary(prev(it), it);",
      "        }",
      "    }",
      "",
      "    // returns the maximum value at x among all inserted lines",
      "    T get_maximum(T x) {",
      "        assert(!this->empty());",
      "        compare_on_intersection = true;",
      "        T res = this->lower_bound({ 0, 0, x })->evaluate(x);",
      "        compare_on_intersection = false;",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "line_container"
  },
  "segment_tree_lazy": {
    "prefix": "segment_tree_lazy",
    "body": [
      "#include <vector>",
      "#include <cassert>",
      "",
      "template<typename T, typename U,",
      "    typename TAssociativeCombineFunction,",
      "    typename UAssociativeCombineFunction,",
      "    typename UApplicator>",
      "struct segment_tree_lazy {",
      "    int SZ;",
      "    T t_identity;",
      "    U u_identity;",
      "    TAssociativeCombineFunction TT;",
      "    UAssociativeCombineFunction UU;",
      "    UApplicator UT;",
      "",
      "    std::vector<T> data;",
      "    std::vector<bool> has_update;",
      "    std::vector<U> updates;",
      "",
      "    segment_tree_lazy() {}",
      "",
      "    segment_tree_lazy(int _SZ, T _t_identity, U _u_identity,",
      "            TAssociativeCombineFunction _TT, UAssociativeCombineFunction _UU, UApplicator _UT)",
      "            : SZ(_SZ), t_identity(_t_identity), u_identity(_u_identity), TT(_TT), UU(_UU), UT(_UT) {",
      "        data.assign(2 * SZ, t_identity);",
      "        has_update.assign(SZ, false);",
      "        updates.assign(SZ, u_identity);",
      "    }",
      "",
      "    template<typename Function>",
      "    void assign(Function fn) {",
      "        for (int i = 0; i < SZ; i++)",
      "            data[SZ + i] = fn(i);",
      "        for (int i = SZ - 1; i; i--)",
      "            data[i] = TT(data[2 * i], data[2 * i + 1]);",
      "        has_update.assign(SZ, false);",
      "        updates.assign(SZ, u_identity);",
      "    }",
      "",
      "private:",
      "    void apply_update(int i, const U &u) {",
      "        data[i] = UT(u, data[i]);",
      "        if (i < SZ) {",
      "            has_update[i] = true;",
      "            updates[i] = UU(u, updates[i]);",
      "        }",
      "    }",
      "",
      "    void propagate_ancestor_updates(int i) {",
      "        for (int ht = 31 - __builtin_clz(i); ht > 0; ht--) {",
      "            int anc = i >> ht;",
      "            if (has_update[anc]) {",
      "                apply_update(2 * anc, updates[anc]);",
      "                apply_update(2 * anc + 1, updates[anc]);",
      "                has_update[anc] = false;",
      "                updates[anc] = u_identity;",
      "            }",
      "        }",
      "    }",
      "",
      "    void recompute_ancestors(int i) {",
      "        for (i /= 2; i; i /= 2)",
      "            data[i] = UT(updates[i], TT(data[2 * i], data[2 * i + 1]));",
      "    }",
      "",
      "    void modify_leaf(int i, T v, bool overwrite) {",
      "        i += SZ;",
      "        propagate_ancestor_updates(i);",
      "        data[i] = overwrite ? v : TT(data[i], v);",
      "        recompute_ancestors(i);",
      "    }",
      "",
      "public:",
      "    // Assigns v at index i",
      "    void assign(int i, T v) {",
      "        modify_leaf(i, v, true);",
      "    }",
      "",
      "    // Replaces the current value at index i with TT(current value, v)",
      "    void combine_and_assign(int i, T v) {",
      "        modify_leaf(i, v, false);",
      "    }",
      "",
      "    // Applies update u to the elements at indices in [first, last)",
      "    void apply_update(int first, int last, U u) {",
      "        assert(0 <= first && last <= SZ);",
      "        first += SZ, last += SZ;",
      "",
      "        propagate_ancestor_updates(first);",
      "        propagate_ancestor_updates(last - 1);",
      "",
      "        for (int i = first, j = last; i < j; i /= 2, j /= 2) {",
      "            if (i&1) apply_update(i++, u);",
      "            if (j&1) apply_update(--j, u);",
      "        }",
      "",
      "        recompute_ancestors(first);",
      "        recompute_ancestors(last - 1);",
      "    }",
      "",
      "    // Accumulates the elements at indices in [first, last)",
      "    T accumulate(int first, int last) {",
      "        assert(0 <= first && last <= SZ);",
      "        first += SZ, last += SZ;",
      "",
      "        propagate_ancestor_updates(first);",
      "        propagate_ancestor_updates(last - 1);",
      "",
      "        T left = t_identity, right = t_identity;",
      "        for (int i = first, j = last; i < j; i /= 2, j /= 2) {",
      "            if (i&1) left = TT(left, data[i++]);",
      "            if (j&1) right = TT(data[--j], right);",
      "        }",
      "        return TT(left, right);",
      "    }",
      "",
      "    // Returns the current value at index i",
      "    T read(int i) {",
      "        i += SZ;",
      "        propagate_ancestor_updates(i);",
      "        return data[i];",
      "    }",
      "};"
    ],
    "description": "segment_tree_lazy"
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "#include <vector>",
      "#include <numeric>",
      "#include <iostream>",
      "",
      "struct union_find {",
      "    struct node {",
      "        int parent, rank, size;",
      "        node (int id = 0) : parent(id), rank(0), size(1) {}",
      "    };",
      "",
      "    mutable std::vector<node> data;",
      "",
      "    union_find(int SZ = 0) : data(SZ) {",
      "        iota(data.begin(), data.end(), 0);",
      "    }",
      "",
      "    // Returns the root of the component containing i",
      "    int find(int i) const {",
      "        if (i != data[i].parent)",
      "            data[i].parent = find(data[i].parent);",
      "        return data[i].parent;",
      "    }",
      "",
      "    bool is_root(int i) const {",
      "        return i == find(i);",
      "    }",
      "",
      "    node& root_node(int i) const {",
      "        return data[find(i)];",
      "    }",
      "",
      "    /* Unites the components containing a and b if they are different.",
      "     * Returns a boolean indicating whether a and b were in different components.",
      "     */",
      "    bool unite(int a, int b) {",
      "        a = find(a), b = find(b);",
      "        if (a == b) return false;",
      "",
      "        if (data[a].rank < data[b].rank)",
      "            std::swap(a, b);",
      "",
      "        data[b].parent = a;",
      "        data[a].size += data[b].size;",
      "        if (data[a].rank == data[b].rank)",
      "            data[a].rank++;",
      "",
      "        return true;",
      "    }",
      "",
      "    friend void pr(const union_find& u) {",
      "        std::cout << \"{\";",
      "        bool first = 1;",
      "        for (int i = 0; i < int(u.data.size()); i++) {",
      "            if (u.is_root(i)) {",
      "                if (!first) std::cout << \", \";",
      "                else first = 0;",
      "                std::cout << \"[ \" << i << \" | rank=\" << u.data[i].rank",
      "                    << \" size=\" << u.data[i].size << \" ]\";",
      "            }",
      "        }",
      "        std::cout << \"}\";",
      "    }",
      "};"
    ],
    "description": "union_find"
  },
  "segment_tree_persistent_lazy": {
    "prefix": "segment_tree_persistent_lazy",
    "body": [
      "template<typename T, typename U, typename TT, typename UU, typename UT, typename I = int>",
      "struct segment_tree_persistent_lazy {",
      "    struct node {",
      "        T val; U upd;",
      "        int left, right;",
      "    };",
      "",
      "    int SZ; T tid; U uid; TT tt; UU uu; UT ut;",
      "    vector<node> data;",
      "    vector<pair<I, int>> root;",
      "",
      "    segment_tree_persistent_lazy() {}",
      "    segment_tree_persistent_lazy(int SZ_, T tid_, U uid_, TT tt_, UU uu_, UT ut_) :",
      "            tid(tid_), uid(uid_), tt(tt_), uu(uu_), ut(ut_) {",
      "        SZ = 1 << (32 - __builtin_clz(SZ_ - 1));",
      "",
      "        data.push_back({ tid, uid, -1, -1 });",
      "        for (int sz = 2; sz <= SZ; sz *= 2)",
      "            data.push_back({ tt(data.back().val, data.back().val), uid, int(data.size()), int(data.size()) });",
      "    }",
      "",
      "    int __apply(int loc, U u) {",
      "        const node &cur = data[loc];",
      "        data.push_back({ ut(u, cur.val), uu(u, cur.upd), cur.left, cur.right });",
      "        return int(data.size()) - 1;",
      "    }",
      "",
      "    void __propagate(int loc) {",
      "        if (memcmp(&data[loc].upd, &uid, sizeof(U))) {",
      "            data[loc].left  = __apply(data[loc].left,  data[loc].upd);",
      "            data[loc].right = __apply(data[loc].right, data[loc].upd);",
      "            data[loc].upd = uid;",
      "        }",
      "    }",
      "",
      "    // Assigns value v to the element at index i during moment w",
      "    void assign(int i, T v, I w, bool replace = true) {",
      "        assert(0 <= i && i < SZ && (root.empty() || root.back().first <= w));",
      "        root.emplace_back(w, __assign(i, v, w, root.empty() ? __builtin_ctz(SZ) : root.back().second, 0, SZ, replace));",
      "    }",
      "    int __assign(int i, T v, I w, int loc, int L, int R, bool replace) {",
      "        if (R - L == 1) {",
      "            data.push_back({ replace ? v : tt(data[loc].val, v), uid, -1, -1 });",
      "        } else {",
      "            __propagate(loc);",
      "            int M = L + (R - L) / 2;",
      "            int left  = i <  M ? __assign(i, v, w, data[loc].left,  L, M, replace) : data[loc].left;",
      "            int right = M <= i ? __assign(i, v, w, data[loc].right, M, R, replace) : data[loc].right;",
      "            data.push_back({ tt(data[left].val, data[right].val), uid, left, right });",
      "        }",
      "        return int(data.size()) - 1;",
      "    }",
      "",
      "    // Applies update u to the elements at indices in [i, j) during moment w",
      "    void update(int i, int j, U u, I w) {",
      "        if (i >= j) return;",
      "        assert(0 <= i && j <= SZ && (root.empty() || root.back().first <= w));",
      "        root.emplace_back(w, __update(i, j, u, w, root.empty() ? __builtin_ctz(SZ) : root.back().second, 0, SZ));",
      "    }",
      "    int __update(int i, int j, U u, I w, int loc, int L, int R) {",
      "        if (L == i && j == R) {",
      "            return __apply(loc, u);",
      "        } else {",
      "            __propagate(loc);",
      "            int M = L + (R - L) / 2;",
      "            int left  = i < M ? __update(i, min(j, M), u, w, data[loc].left,  L, M) : data[loc].left;",
      "            int right = M < j ? __update(max(i, M), j, u, w, data[loc].right, M, R) : data[loc].right;",
      "            data.push_back({ tt(data[left].val, data[right].val), uid, left, right });",
      "            return int(data.size()) - 1;",
      "        }",
      "    }",
      "",
      "    // Accumulates the elements at indices in [i, j) as they were before moment w",
      "    T accumulate(int i, int j, I w) {",
      "        if (i >= j) return tid;",
      "        assert(0 <= i && j <= SZ);",
      "        return __accumulate(i, j, w, tid, root_before(w), 0, SZ);",
      "    }",
      "    int root_before(I w) const {",
      "        static auto cmp = [](pair<I, int> a, pair<I, int> b) { return a.first < b.first; };",
      "        auto it = lower_bound(root.begin(), root.end(), make_pair(w, tid), cmp);",
      "        return it != root.begin() ? prev(it)->second : __builtin_ctz(SZ);",
      "    }",
      "    T __accumulate(int i, int j, I w, T init, int loc, int L, int R) {",
      "        if (L == i && j == R) {",
      "            init = tt(init, data[loc].val);",
      "        } else {",
      "            __propagate(loc);",
      "            int M = L + (R - L) / 2;",
      "            if (i < M) init = __accumulate(i, min(j, M), w, init, data[loc].left,  L, M);",
      "            if (M < j) init = __accumulate(max(i, M), j, w, init, data[loc].right, M, R);",
      "        }",
      "        return init;",
      "    }",
      "};"
    ],
    "description": "segment_tree_persistent_lazy"
  },
  "segment_tree_searchable": {
    "prefix": "segment_tree_searchable",
    "body": [
      "// {{{ data_structures/segment_tree.cpp }}}",
      "",
      "#include <cassert>",
      "",
      "template<typename T, typename AssociativeOperation>",
      "struct searchable_segment_tree : segment_tree<T, AssociativeOperation> {",
      "    using segment_tree<T, AssociativeOperation>::SZ;",
      "    using segment_tree<T, AssociativeOperation>::identity;",
      "    using segment_tree<T, AssociativeOperation>::TT;",
      "    using segment_tree<T, AssociativeOperation>::data;",
      "",
      "    searchable_segment_tree() {}",
      "",
      "    /* Rounds up internal size to the next power of 2 to enable binary search.",
      "     */",
      "    searchable_segment_tree(int _SZ, T _identity, AssociativeOperation _TT) :",
      "        segment_tree<T, AssociativeOperation>(1 << (32 - __builtin_clz(_SZ - 1)), _identity, _TT) {}",
      "",
      "    /* Returns the smallest index \"last\" >= first such that p(accumulate(first, last))",
      "     * returns true. Returns SZ + 1 if no such index exists. Requires that",
      "     * p(accumulate(first, last)) is non-decreasing as last increases.",
      "     */",
      "    template<typename Predicate>",
      "    int binary_search(int first, Predicate p) const {",
      "        assert(0 <= first && first <= SZ);",
      "",
      "        if (p(identity))",
      "            return first;",
      "",
      "        first += SZ;",
      "",
      "        T accumulator = identity;",
      "",
      "        auto try_extend = [&](int bit) {",
      "            assert(__builtin_ctz(first) >= bit);",
      "",
      "            if (first + (1 << bit) > 2 * SZ)",
      "                return false;",
      "",
      "            T extended = TT(accumulator, data[first >> bit]);",
      "",
      "            if (p(extended))",
      "                return false;",
      "",
      "            accumulator = extended;",
      "            first += 1 << bit;",
      "            return true;",
      "        };",
      "",
      "        int bit = 0;",
      "",
      "        while (!(first & (1 << bit)) || try_extend(bit))",
      "            bit++;",
      "",
      "        while (--bit >= 0)",
      "            try_extend(bit);",
      "",
      "        return first - SZ + 1;",
      "    }",
      "};"
    ],
    "description": "segment_tree_searchable"
  },
  "static_to_dynamic_transformation": {
    "prefix": "static_to_dynamic_transformation",
    "body": [
      "#include <vector>",
      "#include <algorithm>",
      "",
      "template<typename T, typename StaticCollection>",
      "struct static_to_dynamic_transformation {",
      "    int SZ;",
      "    std::vector<T> elements;",
      "    std::vector<StaticCollection> collections;",
      "",
      "    static_to_dynamic_transformation() : SZ(0) {}",
      "",
      "    void insert(T elt) {",
      "        elements.push_back(elt);",
      "",
      "        int index = __builtin_ctz(int(elements.size()));",
      "",
      "        if (index >= int(collections.size()))",
      "            collections.emplace_back();",
      "",
      "        collections[index] = { elements.end() - (1 << index), elements.end() };",
      "",
      "        std::fill(collections.begin(), collections.begin() + index, StaticCollection{});",
      "    }",
      "",
      "    template<typename Query, typename Result, typename CommutativeJoinResults>",
      "    Result accumulate(Query query, Result init, CommutativeJoinResults join) const {",
      "        for (const StaticCollection &c : collections)",
      "            init = join(init, query(c));",
      "        return init;",
      "    }",
      "};"
    ],
    "description": "static_to_dynamic_transformation"
  },
  "splitmix64_hash_map": {
    "prefix": "splitmix64_hash_map",
    "body": [
      "#include <chrono>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "",
      "// https://codeforces.com/blog/entry/62393",
      "",
      "struct sp64_hash {",
      "    static uint64_t splitmix64(uint64_t x) {",
      "        x += 0x9e3779b97f4a7c15;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "        return x ^ (x >> 31);",
      "    }",
      "",
      "    static uint64_t random_address() { char *p = new char; delete p; return uint64_t(p); }",
      "",
      "    size_t operator()(uint64_t x) const {",
      "        static const uint64_t FIXED_RANDOM = splitmix64((random_address() | 1)",
      "                * std::chrono::steady_clock::now().time_since_epoch().count());",
      "        return splitmix64(x ^ FIXED_RANDOM);",
      "    }",
      "};",
      "",
      "template<typename K>",
      "struct sp64_pair_hash {",
      "    size_t operator()(const std::pair<K, K>& x) const {",
      "        static_assert(sizeof(K) <= 4, \"type K has size exceeding 32 bits\");",
      "        static sp64_hash sp64;",
      "        return sp64(((uint64_t) x.first << 32) ^ x.second);",
      "    }",
      "};",
      "",
      "template<class K, class V>",
      "using umap = __gnu_pbds::gp_hash_table<K, V, sp64_hash>;"
    ],
    "description": "splitmix64_hash_map"
  },
  "line_container_monotonic": {
    "prefix": "line_container_monotonic",
    "body": [
      "// {{{ data_structures/line }}}",
      "",
      "#include <vector>",
      "#include <cassert>",
      "",
      "template<typename T>",
      "struct line_container_monotonic : std::vector<line<T>> {",
      "    /* Inserts the line f(x) = a * x + b.",
      "     * a must be non-decreasing across calls.",
      "     */",
      "    void insert_line(T a, T b) {",
      "        line<T> ins = { a, b };",
      "",
      "        if (!this->empty()) {",
      "            auto it = this->rbegin();",
      "",
      "            if (it->a > a)",
      "                assert(false);",
      "",
      "            if (it->a == a && it->b >= b)",
      "                return;",
      "",
      "            it->intersects_next = it->compute_intersection(ins);",
      "",
      "            while (this->size() >= 2 && next(it)->intersects_next >= it->intersects_next) {",
      "                this->pop_back();",
      "                it = next(it);",
      "                it->intersects_next = it->compute_intersection(ins);",
      "            }",
      "        }",
      "",
      "        this->push_back(ins);",
      "    }",
      "",
      "    /* Returns the maximum value at x among all inserted lines.",
      "     */",
      "    T get_maximum(T x) const {",
      "        assert(!this->empty());",
      "        return std::lower_bound(this->begin(), this->end(), x, [](const line<T> &l, int _x) {",
      "            return l.intersects_next < _x;",
      "        })->evaluate(x);",
      "    }",
      "",
      "    /* Returns the maximum value at x among all inserted lines.",
      "     * Total runtime complexity is linear over sequential calls made",
      "     * with non-decreasing x if position is not modified externally.",
      "     */",
      "    T get_maximum_monotonic(T x, size_t &position) const {",
      "        assert(!this->empty());",
      "",
      "        if (position > this->size())",
      "            position = this->size();",
      "",
      "        while (position > 0 && (*this)[position - 1].intersects_next >= x)",
      "            position--;",
      "",
      "        while (x > (*this)[position].intersects_next)",
      "            position++;",
      "",
      "        return (*this)[position].evaluate(x);",
      "    }",
      "};"
    ],
    "description": "line_container_monotonic"
  },
  "segment_tree": {
    "prefix": "segment_tree",
    "body": [
      "#include <vector>",
      "#include <cassert>",
      "",
      "template<typename T, typename AssociativeOperation>",
      "struct segment_tree {",
      "    int SZ;",
      "    T identity;",
      "    AssociativeOperation TT;",
      "    std::vector<T> data;",
      "",
      "    segment_tree() {}",
      "",
      "    segment_tree(int _SZ, T _identity, AssociativeOperation _TT)",
      "            : SZ(_SZ), identity(_identity), TT(_TT) {",
      "        data.resize(2 * SZ, identity);",
      "    }",
      "",
      "    // Returns the value at index i",
      "    const T& operator[](int i) const {",
      "        assert(0 <= i && i < SZ);",
      "        return data[SZ + i];",
      "    }",
      "",
      "    // Assigns fn(i) at index i for each i in [0, SZ)",
      "    template<typename Function>",
      "    void assign(Function fn) {",
      "        for (int i = 0; i < SZ; i++)",
      "            data[SZ + i] = fn(i);",
      "        for (int i = SZ - 1; i; i--)",
      "            data[i] = TT(data[2 * i], data[2 * i + 1]);",
      "    }",
      "",
      "    // Assigns v at index i",
      "    void assign(int i, T v) {",
      "        assert(0 <= i && i < SZ);",
      "        data[i += SZ] = v;",
      "        for (i /= 2; i; i /= 2)",
      "            data[i] = TT(data[2 * i], data[2 * i + 1]);",
      "    }",
      "",
      "    // Returns the result of a left fold of the elements at indices in [first, last) over TT",
      "    T accumulate(int first, int last) const {",
      "        assert(0 <= first && last <= SZ);",
      "        T left = identity, right = identity;",
      "        for (first += SZ, last += SZ; first < last; first /= 2, last /= 2) {",
      "            if (first & 1) left  = TT(left, data[first++]);",
      "            if (last  & 1) right = TT(data[--last], right);",
      "        }",
      "        return TT(left, right);",
      "    }",
      "};"
    ],
    "description": "segment_tree"
  },
  "union_find_bipartite": {
    "prefix": "union_find_bipartite",
    "body": [
      "#include <vector>",
      "#include <cassert>",
      "#include <numeric>",
      "",
      "struct union_find_bipartite {",
      "    struct node {",
      "        int parent, rank, size, status;",
      "        bool parent_edge_parity;",
      "        bool is_bipartite;",
      "        int ct_nodes_on_root_side;",
      "",
      "        node() {}",
      "",
      "        node(int id) : parent(id), rank(0), size(1), status(-1),",
      "                parent_edge_parity(0), is_bipartite(true), ct_nodes_on_root_side(1) {}",
      "",
      "        int count_bipartitions() const {",
      "            return !is_bipartite ? 0 : status == -1 ? 2 : 1;",
      "        }",
      "",
      "        int min_nodes_on_side_1() const {",
      "            switch (status) {",
      "                case  1: return ct_nodes_on_root_side;",
      "                case  0: return size - ct_nodes_on_root_side;",
      "                case -1: return std::min(ct_nodes_on_root_side, size - ct_nodes_on_root_side);",
      "                default: assert(false);",
      "            }",
      "        }",
      "    };",
      "",
      "    int ct_components, ct_bipartite_components, degrees_of_freedom, min_nodes_on_side_1;",
      "    mutable std::vector<node> data;",
      "",
      "    union_find_bipartite(int N = 0) : ct_components(N), ct_bipartite_components(N),",
      "            degrees_of_freedom(N), min_nodes_on_side_1(0), data(N) {",
      "        iota(data.begin(), data.end(), 0);",
      "    }",
      "",
      "private:",
      "    void subtract_component(int u) {",
      "        ct_components--;",
      "        if (data[u].is_bipartite) {",
      "            ct_bipartite_components--;",
      "            degrees_of_freedom -= data[u].status == -1;",
      "            min_nodes_on_side_1 -= data[u].min_nodes_on_side_1();",
      "        }",
      "    }",
      "",
      "    void add_component(int u) {",
      "        ct_components++;",
      "        if (data[u].is_bipartite) {",
      "            ct_bipartite_components++;",
      "            degrees_of_freedom += data[u].status == -1;",
      "            min_nodes_on_side_1 += data[u].min_nodes_on_side_1();",
      "        }",
      "    }",
      "",
      "public:",
      "    int find(int u) const {",
      "        if (u == data[u].parent) return u;",
      "        find(data[u].parent);",
      "        data[u].parent_edge_parity ^= data[data[u].parent].parent_edge_parity;",
      "        return data[u].parent = data[data[u].parent].parent;",
      "    }",
      "",
      "    bool can_constrain_node_to_side(int u, bool side) const {",
      "        find(u);",
      "        side ^= data[u].parent_edge_parity;",
      "        u = data[u].parent;",
      "",
      "        return data[u].is_bipartite &&",
      "            (data[u].status == -1 || data[u].status == side);",
      "    }",
      "",
      "    bool constrain_node_to_side(int u, bool side) {",
      "        find(u);",
      "        side ^= data[u].parent_edge_parity;",
      "        u = data[u].parent;",
      "",
      "        subtract_component(u);",
      "",
      "        if (data[u].status == -1) {",
      "            data[u].status = side;",
      "        } else {",
      "            data[u].is_bipartite &= data[u].status == side;",
      "        }",
      "",
      "        add_component(u);",
      "        return data[u].is_bipartite;",
      "    }",
      "",
      "    bool can_add_constraint_on_nodes(int u, int v, bool edge_parity) const {",
      "        find(u);",
      "        edge_parity ^= data[u].parent_edge_parity;",
      "        u = data[u].parent;",
      "",
      "        find(v);",
      "        edge_parity ^= data[v].parent_edge_parity;",
      "        v = data[v].parent;",
      "",
      "        return data[u].is_bipartite && data[v].is_bipartite &&",
      "            (data[u].status == -1 || data[v].status == -1 || (data[u].status ^ data[v].status) == edge_parity);",
      "    }",
      "",
      "    struct result {",
      "        bool added_connectivity;",
      "        bool component_is_bipartite;",
      "    };",
      "",
      "    result unite(int u, int v, bool edge_parity) {",
      "        find(u);",
      "        edge_parity ^= data[u].parent_edge_parity;",
      "        u = data[u].parent;",
      "",
      "        find(v);",
      "        edge_parity ^= data[v].parent_edge_parity;",
      "        v = data[v].parent;",
      "",
      "        if (u == v) {",
      "            subtract_component(u);",
      "            if (edge_parity)",
      "                data[u].is_bipartite = false;",
      "            add_component(u);",
      "            return {false, data[u].is_bipartite};",
      "        }",
      "",
      "        if (data[u].rank < data[v].rank)",
      "            std::swap(u, v);",
      "",
      "        subtract_component(u);",
      "        subtract_component(v);",
      "",
      "        data[v].parent = u;",
      "",
      "        data[v].parent_edge_parity = edge_parity;",
      "",
      "        if (data[u].rank == data[v].rank)",
      "            data[u].rank++;",
      "",
      "        data[u].size += data[v].size;",
      "",
      "        data[u].is_bipartite &= data[v].is_bipartite;",
      "",
      "        if (edge_parity)",
      "            data[u].ct_nodes_on_root_side += data[v].size - data[v].ct_nodes_on_root_side;",
      "        else",
      "            data[u].ct_nodes_on_root_side += data[v].ct_nodes_on_root_side;",
      "",
      "        if (data[v].status != -1) {",
      "            bool implied_u_status = data[v].status ^ edge_parity;",
      "            if (data[u].status == -1)",
      "                data[u].status = implied_u_status;",
      "            else",
      "                data[u].is_bipartite &= data[u].status == implied_u_status;",
      "        }",
      "",
      "        add_component(u);",
      "        return {true, data[u].is_bipartite};",
      "    }",
      "",
      "    bool can_constrain_to_be_same      (int u, int v) const { return can_add_constraint_on_nodes(u, v, 0); }",
      "    bool can_constrain_to_be_different (int u, int v) const { return can_add_constraint_on_nodes(u, v, 1); }",
      "",
      "    result constrain_to_be_same        (int u, int v) { return unite(u, v, 0); }",
      "    result constrain_to_be_different   (int u, int v) { return unite(u, v, 1); }",
      "};"
    ],
    "description": "union_find_bipartite"
  },
  "piecewise_linear_convex_function": {
    "prefix": "piecewise_linear_convex_function",
    "body": [
      "template<typename T> struct PWLC {",
      "    T y0;",
      "    max_heap<pair<T, T>> left;",
      "    min_heap<pair<T, T>> right;",
      "    T left_offset = 0, right_offset = 0;",
      "",
      "    PWLC(T y0_ = 0) : y0(y0_) {}",
      "",
      "    /* __ : y = alpha */",
      "    static PWLC constant(T alpha) { return PWLC(alpha); }",
      "    /* \\_ : y = max(0, beta * (x - x0)) */",
      "    static PWLC decreasing(T x0, T beta = -1) { assert(beta <= 0); PWLC f; f.left.push({ x0, -beta }); return f; }",
      "    /* _/ : y = max(0, beta * (x - x0)) */",
      "    static PWLC increasing(T x0, T beta =  1) { assert(beta >= 0); PWLC f; f.right.push({ x0, beta }); return f; }",
      "    /* \\/ : y = beta * abs(x - x0) */",
      "    static PWLC abs(T x0, T beta = 1) { return decreasing(x0, -beta) + increasing(x0, beta); }",
      "",
      "    /* f'(x) = f(x + c) */",
      "    void shift(int c) { left_offset -= c; right_offset -= c; }",
      "    /* \\_/ => \\__ : f'(x') = min_{x <= x'} f(x) */",
      "    void prefix_min() { while (!right.empty()) right.pop(); }",
      "    /* \\_/ => __/ : f'(x') = min_{x >= x'} f(x) */",
      "    void suffix_min() { while (!left.empty()) left.pop(); }",
      "    /* \\_/ => \\__/ : f'(x') = min_{dx in [xl, xr]} f(x' + dx) */",
      "    void range_min(T xl, T xr) {",
      "        assert(xl <= xr);",
      "        if (xl > 0) shift(xl), tie(xl, xr) = make_pair(0, xr - xl);",
      "        if (xr < 0) shift(xr), tie(xl, xr) = make_pair(xl - xr, 0);",
      "        left_offset -= xr;",
      "        right_offset -= xl;",
      "    }",
      "",
      "    T minimum() const { return y0; }",
      "    T left_arg_min() const { return left.empty() ? numeric_limits<T>::min() : (left.top().first + left_offset); }",
      "    T right_arg_min() const { return right.empty() ? numeric_limits<T>::max() : (right.top().first + right_offset); }",
      "",
      "    void operator+=(PWLC o) {",
      "        y0 += o.y0;",
      "        for (; !o.left.empty(); o.left.pop()) {",
      "            T x = o.left.top().first + o.left_offset;",
      "            T beta_change = o.left.top().second;",
      "",
      "            if (x <= right_arg_min()) {",
      "                left.push({ x - left_offset, beta_change });",
      "            } else {",
      "                T x0 = right_arg_min();",
      "                y0 += (x - x0) * beta_change;",
      "                right.push({ x - right_offset, beta_change });",
      "                for (T beta = beta_change; beta > 0; ) {",
      "                    T next_change = right.top().second;",
      "                    right.pop();",
      "                    if (next_change >= beta) {",
      "                        left.push({ x0 - left_offset, beta });",
      "                        if (next_change > beta) right.push({ x0 - right_offset, next_change - beta });",
      "                        beta = 0;",
      "                    } else {",
      "                        beta -= next_change;",
      "                        y0 -= beta * (right_arg_min() - x0);",
      "                        x0 = right_arg_min();",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        for (; !o.right.empty(); o.right.pop()) {",
      "            T x = o.right.top().first + o.right_offset;",
      "            T beta_change = o.right.top().second;",
      "",
      "            if (x >= left_arg_min()) {",
      "                right.push({ x - right_offset, beta_change });",
      "            } else {",
      "                T x0 = left_arg_min();",
      "                y0 += (x0 - x) * beta_change;",
      "                left.push({ x - left_offset, beta_change });",
      "                for (T beta = beta_change; beta > 0; ) {",
      "                    T next_change = left.top().second;",
      "                    left.pop();",
      "                    if (next_change >= beta) {",
      "                        right.push({ x0 - right_offset, beta });",
      "                        if (next_change > beta) left.push({ x0 - left_offset, next_change - beta });",
      "                        beta = 0;",
      "                    } else {",
      "                        beta -= next_change;",
      "                        y0 -= beta * (x0 - left_arg_min());",
      "                        x0 = left_arg_min();",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    friend PWLC operator+(const PWLC &a, const PWLC &b) { PWLC f(a); f += b; return f; }",
      "};"
    ],
    "description": "piecewise_linear_convex_function"
  },
  "union_find_rewindable": {
    "prefix": "union_find_rewindable",
    "body": [
      "#include <vector>",
      "#include <numeric>",
      "#include <cassert>",
      "",
      "// {{{ data_structures/splitmix64_hash_map }}}",
      "",
      "struct union_find_rewindable {",
      "    struct node {",
      "        int parent, rank, size;",
      "        node (int id = 0) : parent(id), rank(0), size(1) {}",
      "    };",
      "",
      "    struct modification {",
      "        int parent, child;",
      "        node previous_value;",
      "    };",
      "",
      "    std::vector<node> data;",
      "    std::vector<modification> history;",
      "",
      "    union_find_rewindable(int SZ = 0) : data(SZ) {",
      "        iota(data.begin(), data.end(), 0);",
      "    }",
      "",
      "    // Returns the root of the component containing i",
      "    int find(int i) const {",
      "        while (i != data[i].parent)",
      "            i = data[i].parent;",
      "        return i;",
      "    }",
      "",
      "    bool is_root(int i) const {",
      "        return i == find(i);",
      "    }",
      "",
      "    const node& root_node(int i) const {",
      "        return data[find(i)];",
      "    }",
      "",
      "    /* Unites the components containing a and b if they are different.",
      "     * Returns a boolean indicating whether a and b were in different components.",
      "     */",
      "    bool unite(int a, int b) {",
      "        a = find(a), b = find(b);",
      "        if(a == b) return false;",
      "",
      "        if (data[a].rank < data[b].rank)",
      "            std::swap(a, b);",
      "",
      "        history.push_back({ a, b, data[a] });",
      "",
      "        data[b].parent = a;",
      "        data[a].size += data[b].size;",
      "        if (data[a].rank == data[b].rank)",
      "            data[a].rank++;",
      "",
      "        return true;",
      "    }",
      "",
      "    int component_count() const {",
      "        return int(data.size() - history.size());",
      "    }",
      "",
      "    int version() const {",
      "        return int(history.size());",
      "    }",
      "",
      "    void rewind(int version_id) {",
      "        assert(0 <= version_id && version_id <= int(history.size()));",
      "        while (int(history.size()) > version_id) {",
      "            auto [parent, child, previous_value] = history.back();",
      "",
      "            data[parent] = previous_value;",
      "            data[child].parent = child;",
      "",
      "            history.pop_back();",
      "        }",
      "    }",
      "};",
      "",
      "/* Processes a sequence of events (u, v) toggling undirected edges",
      " * in a graph on vertex_count vertices. If an edge between u and v",
      " * is present, it's removed; otherwise, one is added.",
      " *",
      " * Returns f[x] = the number of components in the graph after",
      " * processing the first x events.",
      " */",
      "std::vector<int> get_component_counts(int vertex_count,",
      "        std::vector<std::pair<int, int>> edge_sequence) {",
      "    const int E = int(edge_sequence.size());",
      "",
      "    std::vector<int> matching_operation(E, E);",
      "    __gnu_pbds::gp_hash_table<std::pair<int, int>, int,",
      "        sp64_pair_hash<int>> inserted_by;",
      "",
      "    for (int i = 0; i < E; i++) {",
      "        auto it = inserted_by.find(edge_sequence[i]);",
      "        if (it == inserted_by.end()) {",
      "            inserted_by[edge_sequence[i]] = i;",
      "        } else {",
      "            matching_operation[it->second] = i;",
      "            matching_operation[i] = it->second;",
      "            inserted_by.erase(edge_sequence[i]);",
      "        }",
      "    }",
      "",
      "    union_find_rewindable uf(vertex_count);",
      "",
      "    std::vector<int> component_counts(E + 1);",
      "",
      "    component_counts[0] = uf.component_count();",
      "",
      "    auto solve = [&](auto& self, int first, int last) -> void {",
      "        if (last - first == 1) {",
      "            component_counts[last] = uf.component_count();",
      "            if (matching_operation[first] > first) {",
      "                auto [u, v] = edge_sequence[first];",
      "                component_counts[last] -= uf.find(u) != uf.find(v);",
      "            }",
      "            return;",
      "        }",
      "",
      "        const int mid = first + (last - first) / 2;",
      "        const int initial_state = uf.version();",
      "",
      "        if (first < mid) {",
      "            for (int i = mid; i < last; i++) {",
      "                if (matching_operation[i] < first) {",
      "                    auto [u, v] = edge_sequence[i];",
      "                    uf.unite(u, v);",
      "                }",
      "            }",
      "            self(self, first, mid);",
      "            uf.rewind(initial_state);",
      "        }",
      "",
      "        if (mid < last) {",
      "            for (int i = first; i < mid; i++) {",
      "                if (matching_operation[i] >= last) {",
      "                    auto [u, v] = edge_sequence[i];",
      "                    uf.unite(u, v);",
      "                }",
      "            }",
      "            self(self, mid, last);",
      "            uf.rewind(initial_state);",
      "        }",
      "    };",
      "",
      "    solve(solve, 0, E);",
      "",
      "    return component_counts;",
      "}"
    ],
    "description": "union_find_rewindable"
  },
  "maximum_matching": {
    "prefix": "maximum_matching",
    "body": [
      "int maximum_matching(const int N, const vector<array<int, 2>>& edges) {",
      "    const int INF = 1e9 + 7;",
      "    uniform_int_distribution<int> unif(1, INF - 1);",
      "",
      "    int res = 0;",
      "    for (int rep = 0; rep < 3; rep++) {",
      "        matrix<modnum<INF>> m(N, 0, 0);",
      "        for (auto [u, v] : edges) {",
      "            if (u > v) swap(u, v);",
      "            int eid = unif(rng);",
      "            m(u, v) = eid;",
      "            m(v, u) = -eid;",
      "        }",
      "        res = max(res, m.rank());",
      "    }",
      "    return res / 2;",
      "}"
    ],
    "description": "maximum_matching"
  },
  "min_cost_flow": {
    "prefix": "min_cost_flow",
    "body": [
      "template<typename F, typename C> struct min_cost_flow {",
      "    static constexpr int bits = 63 - __builtin_clzll(numeric_limits<F>::max());",
      "",
      "    int V, E;",
      "    vvi adj;",
      "    vi dest;",
      "    vector<F> cap;",
      "    vector<C> cost;",
      "",
      "    min_cost_flow(int V_ = 0) : V(V_), E(0) {",
      "        adj.resize(V);",
      "    }",
      "",
      "    void __arc(int u, int v, F f, C c) {",
      "        E++;",
      "        adj[u].push_back(sz(dest));",
      "        dest.push_back(v);",
      "        cap.push_back(f);",
      "        cost.push_back(c);",
      "    }",
      "",
      "    // Inserts a directed edge u --> v with capacity f and cost c.",
      "    void arc(int u, int v, F f, C c) {",
      "        __arc(u, v, f, c);",
      "        __arc(v, u, F(0), -c);",
      "    }",
      "",
      "    bool dijkstra(auto& imb, auto& flow, auto& pot, F delta) const {",
      "        priority_queue<tuple<C, int, int>> q;",
      "        vi ent(V, -2);",
      "        vector<C> dist(V, numeric_limits<C>::max());",
      "        for (int v = 0; v < V; v++) if (imb[v] >= delta) {",
      "            dist[v] = 0;",
      "            q.push(make_tuple(0., v, -1));",
      "        }",
      "",
      "        while (!q.empty()) {",
      "            C d; int v, f; tie(d, v, f) = q.top(); q.pop();",
      "            if (ent[v] != -2) continue;",
      "            dist[v] = -d; ent[v] = f;",
      "            for (int e : adj[v]) if (cap[e] - flow[e] >= delta) {",
      "                C cd = dist[v] + (cost[e] + pot[v] - pot[dest[e]]);",
      "                if (cd < dist[dest[e]]) {",
      "                    dist[dest[e]] = cd;",
      "                    q.push(make_tuple(-cd, dest[e], e ));",
      "                }",
      "            }",
      "        }",
      "",
      "        for (int v = 0; v < V; v++) if (ent[v] != -2 && imb[v] <= -delta) {",
      "            for (int u = 0; u < V; u++)",
      "                if (ent[u] != -2) pot[u] += dist[u];",
      "            for (int e = ent[v]; ~e; e = ent[dest[e^1]]) {",
      "                flow[e] += delta;",
      "                flow[e^1] -= delta;",
      "                imb[dest[e]] += delta;",
      "                imb[dest[e^1]] -= delta;",
      "            }",
      "            return true;",
      "        }",
      "        return false;",
      "    }",
      "",
      "    // Computes the minimum cost to satisfy the specified imbalances.",
      "    // Runs in O(E^2 * log V * log inf).",
      "    struct circulation {",
      "        bool feasible;",
      "        C cost;",
      "        vector<F> flow;",
      "    };",
      "    circulation solve(vector<F> imb) const {",
      "        vector<F> flow(E);",
      "        vector<C> pot(V);",
      "        for (F delta = 1ll << bits; delta; delta >>= 1) {",
      "            for (int e = 0; e < E; e++) {",
      "                int u = dest[e^1], v = dest[e];",
      "                F res = cap[e] - flow[e];",
      "                if (res >= delta && cost[e] + pot[u] - pot[v] < 0) {",
      "                    flow[e^1] -= res;",
      "                    flow[e] += res;",
      "                    imb[u] -= res;",
      "                    imb[v] += res;",
      "                }",
      "            }",
      "            while (dijkstra(imb, flow, pot, delta));",
      "        }",
      "",
      "        C ans = 0;",
      "        for (int e = 0; e < E; e++) if (flow[e] > 0)  {",
      "            ans += flow[e] * cost[e];",
      "        }",
      "        return { imb == vector<F>(V, 0), ans, flow };",
      "    }",
      "};"
    ],
    "description": "min_cost_flow"
  },
  "strongly_connected_components": {
    "prefix": "strongly_connected_components",
    "body": [
      "#include <vector>",
      "",
      "struct scc {",
      "    int components;",
      "    std::vector<int> label;",
      "};",
      "",
      "// Labels strongly connected components in reverse topological order.",
      "// That means for any edge u-->v label[u] >= label[v].",
      "scc strongly_connected_components(const std::vector<std::vector<int>>& graph) {",
      "    const int N = int(graph.size());",
      "",
      "    int C = 0, V = 0, top = 0;",
      "    std::vector<int> comp(N, -1), inx(N, -1), stack(N + 1, -1);",
      "",
      "    auto tarjan = [&](auto&& self, int loc) -> int {",
      "        stack[top++] = loc;",
      "        int low = inx[loc] = V++;",
      "        for (int nbr : graph[loc]) {",
      "            if (inx[nbr] == -1) low = std::min(low, self(self, nbr));",
      "            else if (comp[nbr] == -1) low = std::min(low, inx[nbr]);",
      "        }",
      "        if (low == inx[loc]) {",
      "            while (stack[top] != loc)",
      "                comp[stack[--top]] = C;",
      "            C++;",
      "        }",
      "        return low;",
      "    };",
      "",
      "    for (int i = 0; i < N; i++) {",
      "        if (inx[i] == -1)",
      "            tarjan(tarjan, i);",
      "    }",
      "    return { C, comp };",
      "}"
    ],
    "description": "strongly_connected_components"
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "template<typename E> struct graph {",
      "    int V, EC;",
      "    vvi nbrs;",
      "    vector<vector<reference_wrapper<E>>> edges;",
      "    vector<E> edge_list;",
      "",
      "    graph(int _V = 0, int _EC = 0) : V(_V), EC(_EC) {}",
      "    graph(int _V, const vector<E>& __edge_list) : V(_V), EC(sz(__edge_list)), edge_list(__edge_list) {",
      "        nbrs.resize(V), edges.resize(V);",
      "        for (E& e : edge_list) {",
      "            assert(0 <= e.u && e.u < V && 0 <= e.v && e.v < V);",
      "            nbrs[e.u].push_back(e.v);",
      "            nbrs[e.v].push_back(e.u);",
      "            edges[e.u].pb(e);",
      "            edges[e.v].pb(e);",
      "        }",
      "    }",
      "",
      "    friend void re(graph& g) {",
      "        assert(g.V > 0);",
      "        vector<E> __edge_list(g.EC);",
      "        re(__edge_list);",
      "        for (int i = 0; i < g.EC; i++) __edge_list[i].i = i;",
      "        g = graph<E>(__edge_list);",
      "    }",
      "    friend void pr(const graph& g) { pr(\"{V=\", g.V, \" \", g.edge_list, \"}\"); }",
      "};"
    ],
    "description": "graph"
  },
  "tree": {
    "prefix": "tree",
    "body": [
      "#include <cassert>",
      "#include <vector>",
      "#include <iostream>",
      "#include <algorithm>",
      "",
      "struct edge {",
      "    int u_xor_v;",
      "",
      "    edge() : u_xor_v(0) {}",
      "",
      "    edge(int _u_xor_v) : u_xor_v(_u_xor_v) {}",
      "",
      "    int get_nbr(int u) const {",
      "        assert(u_xor_v);",
      "        return u ^ u_xor_v;",
      "    }",
      "",
      "    void read_data() {}",
      "};",
      "",
      "template<typename Data>",
      "struct edge_with_data : edge {",
      "    Data data;",
      "",
      "    edge_with_data() : edge() {}",
      "",
      "    edge_with_data(int _u_xor_v, Data _data) : edge(_u_xor_v), data(_data) {}",
      "",
      "    void read_data() { re(data); }",
      "};",
      "",
      "enum TreeInputFormat { EDGE_LIST, PARENT_LIST };",
      "template<typename Edge>",
      "struct tree {",
      "    int V, root;",
      "    std::vector<std::vector<Edge>> neighbors;",
      "",
      "    std::vector<int> parent, depth, subtree_size, preorder, reverse_preorder;",
      "",
      "    tree() : V(0), root(-1) {}",
      "",
      "    tree(int _V, int _root) : V(_V), root(_root), neighbors(V) {}",
      "",
      "    void add_edge(int u, int v, Edge e = {}) {",
      "        assert(0 <= u && u < V && 0 <= v && v < V);",
      "        e.u_xor_v = u ^ v;",
      "        neighbors[u].push_back(e);",
      "        neighbors[v].push_back(e);",
      "    }",
      "",
      "    const Edge& parent_edge(int u) const {",
      "        assert(u != root);",
      "        return neighbors[u].front();",
      "    }",
      "",
      "    template<typename Function>",
      "    void for_each_child(int u, Function fn) const {",
      "        for (int i = u != root; i < int(neighbors[u].size()); i++)",
      "            fn(neighbors[u][i]);",
      "    }",
      "",
      "    static void DefaultEdgeDataReader(__attribute((unused)) Edge &e) {",
      "        e.read_data();",
      "    }",
      "",
      "    template<typename EdgeDataReader = void(*)(Edge&)>",
      "    friend void re(tree &t, TreeInputFormat Format, int FirstIndex,",
      "            EdgeDataReader read = DefaultEdgeDataReader) {",
      "        assert(t.V > 0);",
      "        for (int i = 0; i < t.V - 1; i++) {",
      "            int u, v;",
      "            std::cin >> u, u -= FirstIndex;",
      "            if (Format == PARENT_LIST) v = i + 1;",
      "            else std::cin >> v, v -= FirstIndex;",
      "            Edge e;",
      "            read(e);",
      "            t.add_edge(u, v, e);",
      "        }",
      "        t.init();",
      "    }",
      "",
      "    void reroot(int _root) {",
      "        root = _root;",
      "        init();",
      "    }",
      "",
      "    void init() {",
      "        parent.resize(V), depth.resize(V), subtree_size.resize(V);",
      "",
      "        parent[root] = -1;",
      "        depth[root] = 0;",
      "",
      "        traverse(root);",
      "",
      "        for (int u = 0; u < V; u++) {",
      "            sort(neighbors[u].begin(), neighbors[u].end(), [&](const Edge &a, const Edge &b) {",
      "                return subtree_size[a.get_nbr(u)] > subtree_size[b.get_nbr(u)];",
      "            });",
      "        }",
      "",
      "        preorder.clear();",
      "        build_preorder(root);",
      "",
      "        reverse_preorder = preorder;",
      "        std::reverse(reverse_preorder.begin(), reverse_preorder.end());",
      "    }",
      "",
      "    void traverse(int u) {",
      "        subtree_size[u] = 1;",
      "        for (Edge e : neighbors[u]) {",
      "            int v = e.get_nbr(u);",
      "            if (v == parent[u]) continue;",
      "",
      "            parent[v] = u;",
      "            depth[v] = depth[u] + 1;",
      "            traverse(v);",
      "            subtree_size[u] += subtree_size[v];",
      "        }",
      "    }",
      "",
      "    void build_preorder(int u) {",
      "        preorder.push_back(u);",
      "        for_each_child(u, [&](Edge e) { build_preorder(e.get_nbr(u)); });",
      "    }",
      "",
      "    static void DefaultEdgeDataWriter(__attribute((unused)) Edge &e) {}",
      "",
      "    template<typename EdgeDataWriter = void(*)(Edge&)>",
      "    friend void pr(const tree& t, EdgeDataWriter write = DefaultEdgeDataWriter) {",
      "        std::cout << \"{V=\" << t.V << \" root=\" << t.root << \" |\";",
      "        for (int u = 0; u < t.V; u++) {",
      "            std::cout << \" \" << u << \"--{\";",
      "            t.for_each_child(u, [&](Edge e) {",
      "                std::cout << \"(ch=\" << e.get_nbr(u);",
      "                write(e);",
      "                std::cout << \")\";",
      "            });",
      "            std::cout << \"}\";",
      "        }",
      "        std::cout << \"}\";",
      "    }",
      "};"
    ],
    "description": "tree"
  },
  "centroid_decomposition": {
    "prefix": "centroid_decomposition",
    "body": [
      "template<typename E, int MAXV, bool PREORDER>",
      "struct centroid_decomposition {",
      "    static const int L = 33 - __builtin_clz(MAXV - 1);",
      "",
      "    const tree<E>& t;",
      "    using P = typename E::path;",
      "    struct visit { int node; E in; };",
      "    vi layer;                        // 0-indexed depth in the centroid tree",
      "    vpii par;                        // {parent, index among parent's children}",
      "    vi child_ct;                     // number of children",
      "    vector<array<P, L>> anc_path;    // paths to ancestors, by layer",
      "    vector<vector<visit>> preorder;  // preorder traversals recording {node, incoming edge}",
      "    vvi ch_sz;                       // child tree sizes in traversal order",
      "",
      "    centroid_decomposition(const tree<E>& _t) : t(_t),",
      "            layer(t.V, -1), par(t.V), child_ct(t.V), anc_path(t.V) {",
      "        assert(t.V <= MAXV);",
      "        if (PREORDER) preorder.resz(t.V), ch_sz.resz(t.V);",
      "        subt_sz = t.subt_sz, decompose(t.root), subt_sz.clear();",
      "    }",
      "",
      "    vi subt_sz;",
      "    int centroid(int r) {",
      "        int c = r;",
      "        FIND: for (E e : t.nbrs[c]) if (int u = e(c); layer[u] == -1) {",
      "            if (subt_sz[u] < subt_sz[c] && 2 * subt_sz[u] >= subt_sz[r]) {",
      "                c = u; goto FIND;",
      "            }",
      "        }",
      "        return c;",
      "    }",
      "",
      "    int ly = 0, rt = 0;",
      "    void traverse(int u, E in) {",
      "        if (PREORDER) preorder[rt].pb({u, in});",
      "        subt_sz[u] = 1;",
      "        for (E e : t.nbrs[u]) if (int v = e(u); v != in(u) && layer[v] == -1) {",
      "            anc_path[v][ly] = anc_path[u][ly] + P(e);",
      "            traverse(v, e);",
      "            subt_sz[u] += subt_sz[v];",
      "        }",
      "    }",
      "",
      "    void decompose(int r = 0, int p = -1, int i = 0) {",
      "        par[r = centroid(r)] = {p, i}, i = 0;",
      "        layer[r] = ly;",
      "        if (PREORDER) preorder[r] = {{r, E()}};",
      "        subt_sz[r] = 1;",
      "        for (E e : t.nbrs[r]) if (int u = e(r); layer[u] == -1) {",
      "            if (PREORDER) ch_sz[r].pb(-sz(preorder[r]));",
      "            rt = r, anc_path[u][ly] = P(e), traverse(u, e);",
      "            if (PREORDER) ch_sz[r].back() += sz(preorder[r]);",
      "            subt_sz[r] += subt_sz[u], child_ct[r]++;",
      "            ly++, decompose(u, r, i++), ly--;",
      "        }",
      "    }",
      "",
      "    int lca(int u, int v) const {",
      "        if (layer[u] < layer[v]) swap(u, v);",
      "        while (layer[u] != layer[v]) u = par[u].f;",
      "        while (u != v) u = par[u].f, v = par[v].f;",
      "        return u;",
      "    }",
      "",
      "    P dist(int u, int v) const {",
      "        int clca = lca(u, v);",
      "        return anc_path[u][layer[clca]] + anc_path[v][layer[clca]];",
      "    }",
      "};"
    ],
    "description": "centroid_decomposition"
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "#include <cstdlib>",
      "#include <queue>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include <cstring>",
      "",
      "template<typename EdgeWeight>",
      "struct WeightedDirectedGraph {",
      "    struct Edge {",
      "        int neighbor;",
      "        EdgeWeight weight;",
      "    };",
      "",
      "    int N;",
      "    std::vector<std::vector<Edge>> adj;",
      "",
      "    WeightedDirectedGraph (int _N) : N(_N), adj(_N) {}",
      "",
      "    void add_directed_edge(int u, int v, EdgeWeight w) {",
      "        adj[u].push_back({v, w});",
      "    }",
      "};",
      "",
      "template<typename PathWeight>",
      "struct ShortestPathTree {",
      "    std::vector<int> parent;",
      "    std::vector<PathWeight> shortest_path_wt;",
      "",
      "    template<typename EdgeWeight, typename JoinPathAndEdge, typename PathWeightLessThan>",
      "    ShortestPathTree(WeightedDirectedGraph<EdgeWeight> g, const std::vector<int> &sources,",
      "            PathWeight init, JoinPathAndEdge join, PathWeightLessThan less_than) {",
      "        struct Path {",
      "            int destination;",
      "            PathWeight weight;",
      "        };",
      "",
      "        auto path_cmp = [&less_than](const Path &a, const Path &b) {",
      "            return less_than(b.weight, a.weight);",
      "        };",
      "",
      "        std::priority_queue<Path, std::vector<Path>, decltype(path_cmp)> pq(path_cmp);",
      "",
      "        parent.assign(g.N, -1);",
      "        shortest_path_wt.assign(g.N, init);",
      "",
      "        for (int source : sources) {",
      "            parent[source] = source;",
      "            pq.push({ source, shortest_path_wt[source] });",
      "        }",
      "",
      "        while (!pq.empty()) {",
      "            Path path = pq.top();",
      "            pq.pop();",
      "",
      "            if (memcmp(&path.weight, &shortest_path_wt[path.destination], sizeof(PathWeight)))",
      "                continue;",
      "",
      "            for (auto edge : g.adj[path.destination]) {",
      "                PathWeight candidate = join(path.weight, edge.weight);",
      "                if (parent[edge.neighbor] == -1 || less_than(candidate, shortest_path_wt[edge.neighbor])) {",
      "                    parent[edge.neighbor] = path.destination;",
      "                    shortest_path_wt[edge.neighbor] = candidate;",
      "                    pq.push({ edge.neighbor, shortest_path_wt[edge.neighbor] });",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    bool is_reachable(int destination) const {",
      "        return parent[destination] != -1;",
      "    }",
      "",
      "    PathWeight distance(int destination) const {",
      "        if (!is_reachable(destination)) assert(false);",
      "        return shortest_path_wt[destination];",
      "    }",
      "",
      "    std::vector<int> list_vertices_on_path(int destination) const {",
      "        if (!is_reachable(destination)) assert(false);",
      "",
      "        std::vector<int> path;",
      "        while (parent[destination] != destination) {",
      "            path.push_back(destination);",
      "            destination = parent[destination];",
      "        }",
      "        path.push_back(destination);",
      "",
      "        std::reverse(path.begin(), path.end());",
      "        return path;",
      "    }",
      "};"
    ],
    "description": "dijkstra"
  },
  "two_sat": {
    "prefix": "two_sat",
    "body": [
      "// {{{ graphs/strongly_connected_components.cpp }}}",
      "// {{{ graphs/digraph_reachability.cpp }}}",
      "",
      "#include <vector>",
      "#include <string>",
      "",
      "struct two_sat {",
      "    std::vector<std::vector<int>> graph;",
      "",
      "    two_sat(int SZ) : graph(2 * SZ) {}",
      "",
      "    int new_var() {",
      "        graph.push_back({});",
      "        graph.push_back({});",
      "        return int(graph.size()) - 1;",
      "    }",
      "",
      "    static inline int neg(int a) { return a^1; }",
      "",
      "    void implies(int a, int b) {",
      "        if (a < 0 || b < 0) return;",
      "        graph[a].push_back(b);",
      "        graph[neg(b)].push_back(neg(a));",
      "    }",
      "",
      "    void assign(int a, int v) {",
      "        if (v) implies(neg(a), a);",
      "        else implies(a, neg(a));",
      "    }",
      "    void constrain_equal(int a, int b) {",
      "        implies(a, b);",
      "        implies(neg(a), neg(b));",
      "    }",
      "    void constrain_not_equal(int a, int b) {",
      "        implies(a, neg(b));",
      "        implies(neg(a), b);",
      "    }",
      "    void constrain_at_most_one(int a, int b) {",
      "        implies(a, neg(b)); // contrapositive is automatic",
      "    }",
      "    void constraint_at_least_one(int a, int b) {",
      "        implies(neg(a), b); // contrapositive is automatic",
      "    }",
      "",
      "    int make_or(int a, int b) {",
      "        if (a < 0) return b;",
      "        if (b < 0) return a;",
      "        int v = new_var();",
      "        implies(a, v);",
      "        implies(b, v);",
      "        return v;",
      "    }",
      "",
      "    int make_and(int a, int b) {",
      "        if (a < 0) return b;",
      "        if (b < 0) return a;",
      "        int v = new_var();",
      "        implies(v, a);",
      "        implies(v, b);",
      "        return v;",
      "    }",
      "",
      "    std::vector<bool> solve() const {",
      "        scc s = strongly_connected_components(graph);",
      "        std::vector<bool> assignment(int(graph.size()) / 2);",
      "",
      "        for (int v = 0; v < int(graph.size()); v += 2) {",
      "            if (s.label[v] == s.label[v + 1])",
      "                return {};",
      "",
      "            assignment[v / 2] = s.label[v] > s.label[v + 1];",
      "        }",
      "        return assignment;",
      "    }",
      "",
      "    // (2 * MAXV)^2 / machine word size",
      "    template<int MAXV>",
      "    std::string classify() const {",
      "        auto reach = digraph_reachability<2 * MAXV>(graph);",
      "        std::string res(int(graph.size()), '?');",
      "        for (int v = 0; v < int(graph.size()); v++) {",
      "            bool n0 = reach[v][neg(v)];",
      "            bool n1 = reach[neg(v)][v];",
      "            if (n0 && n1) return \"\";",
      "            res[v] = n0 ? '0' : n1 ? '1' : '?';",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "two_sat"
  },
  "dinic": {
    "prefix": "dinic",
    "body": [
      "template<typename F> struct dinic {",
      "    static const F inf = numeric_limits<F>::max();",
      "",
      "    int V;",
      "    vvi adj;",
      "    vi dest;",
      "    vector<F> cap;",
      "",
      "    dinic (int V = 0) : V(V) {",
      "        adj.resize(V);",
      "    }",
      "",
      "    void __arc(int u, int v, F c) {",
      "        adj[u].push_back(dest.size());",
      "        dest.push_back(v);",
      "        cap.push_back(c);",
      "    }",
      "",
      "    // Inserts a directed edge u --> v with capacity c.",
      "    int arc(int u, int v, F c) {",
      "        __arc(u, v, c);",
      "        __arc(v, u, F(0));",
      "        return sz(dest) - 2;",
      "    }",
      "",
      "    mutable vi level;",
      "    void bfs(int s, vector<F>& flow) const {",
      "        level.resz(V), fill(all(level), -1), level[s] = 0;",
      "        for (queue<int> q({s}); !q.empty(); q.pop()) {",
      "            for (int e : adj[q.front()]) {",
      "                if (level[dest[e]] == -1 && flow[e] < cap[e]) {",
      "                    level[dest[e]] = level[q.front()] + 1;",
      "                    q.push(dest[e]);",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    mutable vi inx;",
      "    F augment(int s, int t, vector<F>& flow, F cur = inf) const {",
      "        if (s == t) return cur;",
      "        for (; inx[s] < adj[s].size(); inx[s]++) {",
      "            int e = adj[s][inx[s]];",
      "            if (level[dest[e]] != level[s] + 1) continue;",
      "            if (flow[e] == cap[e]) continue;",
      "            if (F incr = augment(dest[e], t, flow, min(cur, cap[e] - flow[e]))) {",
      "                flow[e] += incr;",
      "                flow[e^1] -= incr;",
      "                return incr;",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "",
      "    /*",
      "     * Computes a maximum flow from node s to node t.",
      "     *",
      "     * Runs in O(V^2 * E) in the general case.",
      "     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.",
      "     * Runs in O(V^(1/2) * E) for bipartite matching.",
      "     */",
      "    struct max_flow {",
      "        F res;",
      "        vector<F> flow;",
      "    };",
      "    max_flow solve(int s, int t) const {",
      "        assert(s != t);",
      "        F res = 0;",
      "        vector<F> flow(cap.size());",
      "        while (bfs(s, flow), ~level[t]) {",
      "            inx.resz(V), fill(all(inx), 0);",
      "            while (F incr = augment(s, t, flow))",
      "                res += incr;",
      "        }",
      "        return max_flow{res, flow};",
      "    }",
      "};"
    ],
    "description": "dinic"
  },
  "digraph_reachability": {
    "prefix": "digraph_reachability",
    "body": [
      "// {{{ graphs/strongly_connected_components.cpp }}}",
      "",
      "#include <vector>",
      "#include <bitset>",
      "#include <cassert>",
      "#include <numeric>",
      "#include <algorithm>",
      "",
      "template<int MAXV>",
      "std::vector<std::bitset<MAXV>> digraph_reachability(",
      "        const std::vector<std::vector<int>> &graph) {",
      "    int V = int(graph.size());",
      "    assert(V <= MAXV);",
      "",
      "    scc s = strongly_connected_components(graph);",
      "",
      "    std::vector<std::bitset<MAXV>> component_reachability(s.components);",
      "",
      "    for (int v = 0; v < s.components; v++)",
      "        component_reachability[s.label[v]][v] = true;",
      "",
      "    std::vector<int> order;",
      "    std::iota(order.begin(), order.end(), 0);",
      "    sort(order.begin(), order.end(),",
      "            [&](int u, int v) { return s.label[u] < s.label[v]; });",
      "",
      "    for (int u : order)",
      "        for (int v : graph[u])",
      "            component_reachability[s.label[u]]",
      "                |= component_reachability[s.label[v]];",
      "",
      "    std::vector<std::bitset<MAXV>> reach(V);",
      "    for (int v = 0; v < V; v++)",
      "        reach[v] = component_reachability[s.label[v]];",
      "    return reach;",
      "}"
    ],
    "description": "digraph_reachability"
  },
  "heavy_path_decomposition": {
    "prefix": "heavy_path_decomposition",
    "body": [
      "// {{{ graphs/tree.cpp }}}",
      "",
      "using index_t = unsigned int;",
      "using interval_t = std::pair<index_t, index_t>;",
      "using path_t = std::vector<interval_t>;",
      "",
      "template<typename Edge>",
      "struct heavy_path_decomposition {",
      "    const tree<Edge> &t;",
      "",
      "    struct node {",
      "        index_t index;",
      "        int heavy_path_top;",
      "    };",
      "    std::vector<node> data;",
      "",
      "    heavy_path_decomposition() {}",
      "",
      "    heavy_path_decomposition(const tree<Edge> &_t) : t(_t), data(t.V) {",
      "        int current_heavy_path_top = -1;",
      "        for (int i = 0; i < t.V; i++) {",
      "            int u = t.preorder[i];",
      "",
      "            if (i == 0 || t.preorder[i - 1] != t.parent[u])",
      "                current_heavy_path_top = u;",
      "",
      "            data[u] = { (unsigned int)i, current_heavy_path_top };",
      "        }",
      "    }",
      "",
      "    index_t index(int v) const {",
      "        return data[v].index;",
      "    }",
      "",
      "    int at_index(index_t i) const {",
      "        return t.preorder[i];",
      "    }",
      "",
      "    int htop(int v) const {",
      "        return data[v].heavy_path_top;",
      "    }",
      "",
      "    int lca(int u, int v) const {",
      "        while (htop(u) != htop(v)) {",
      "            int& jump = index(htop(u)) > index(htop(v)) ? u : v;",
      "            jump = t.par[htop(jump)];",
      "        }",
      "        return t.depth[u] < t.depth[v] ? u : v;",
      "    }",
      "",
      "    int dist(int u, int v) const {",
      "        return t.depth[u] + t.depth[v] - 2 * t.depth[lca(u, v)];",
      "    }",
      "",
      "    bool uv_path_has_w(int u, int v, int w) const {",
      "        return w != -1 && dist(u, v) == (dist(u, w) + dist(w, v));",
      "    }",
      "",
      "    bool is_ancestor(int anc, int desc) const {",
      "        return index(anc) <= index(desc) && index(desc) < index(anc) + t.subt_sz[anc];",
      "    }",
      "",
      "    Edge first_step(int u, int v) const {",
      "        assert(u != v);",
      "        if (!is_ancestor(u, v)) return t.up_edge(u);",
      "        return *upper_bound(all(t.children[u]), v,",
      "            [&](int _v, Edge c) { return index(v) < index(c(u)) + t.subt_sz[c(u)]; });",
      "    }",
      "",
      "    int kth_ancestor(int u, int k) const {",
      "        assert(0 <= k && k <= t.depth[u]);",
      "        while (true) {",
      "            int dist_to_htop = t.depth[u] - t.depth[htop(u)];",
      "            if (k <= dist_to_htop)",
      "                return at_index(index(u) - k);",
      "            u = t.par[htop(u)];",
      "            k -= dist_to_htop + 1;",
      "        }",
      "    }",
      "",
      "    int kth_step(int u, int v, int k) const {",
      "        int w = lca(u, v), d = dist(u, v);",
      "        assert(d >= k);",
      "        return k <= t.depth[u] - t.depth[w] ? kth_ancestor(u, k) : kth_ancestor(v, d - k);",
      "    }",
      "",
      "    mutable int path_lca;",
      "    mutable path_t path_up, path_down;",
      "    void decompose_path(int u, int v, bool include_lca) const {",
      "        path_up.clear(), path_down.clear();",
      "        while (htop(u) != htop(v)) {",
      "            int &jump = index(htop(u)) > index(htop(v)) ? u : v;",
      "            (jump == u ? path_up : path_down).emplace_back(index(htop(jump)), index(jump) + 1);",
      "            jump = t.parent[htop(jump)];",
      "        }",
      "",
      "        path_lca = t.depth[u] < t.depth[v] ? u : v;",
      "        if (u != v || include_lca) {",
      "            path_t &side = (u == path_lca ? path_down : path_up);",
      "            side.emplace_back(index(path_lca) + !include_lca, index(path_lca ^ u ^ v) + 1);",
      "        }",
      "",
      "        reverse(path_down.begin(), path_down.end());",
      "    }",
      "",
      "    template<typename LeftFold, typename RightFold>",
      "    void for_each(int u, int v, bool include_lca, LeftFold left_fold, RightFold right_fold) const {",
      "        decompose_path(u, v, include_lca);",
      "        for (interval_t r : path_up)    left_fold(r.first, r.second);",
      "        for (interval_t r : path_down) right_fold(r.first, r.second);",
      "    }",
      "",
      "    template<typename LeftFold>",
      "    void for_each_commutative(int u, int v, bool include_lca, LeftFold left_fold) const {",
      "        for_each(u, v, include_lca, left_fold, left_fold);",
      "    }",
      "",
      "    template<typename T, typename AssociativeOperation, typename LeftFold, typename RightFold>",
      "    T accumulate(int u, int v, bool include_lca, T init,",
      "            AssociativeOperation op, LeftFold left_fold, RightFold right_fold) {",
      "        decompose_path(u, v, include_lca);",
      "        for (interval_t r : path_up)   init = op(init,  left_fold(r.first, r.second));",
      "        for (interval_t r : path_down) init = op(init, right_fold(r.first, r.second));",
      "        return init;",
      "    }",
      "",
      "    template<typename T, typename AssociativeOperation, typename LeftFold>",
      "    T accumulate_commutative(int u, int v, bool include_lca, T init,",
      "            AssociativeOperation op, LeftFold left_fold) {",
      "        return accumulate(u, v, include_lca, init, op, left_fold, left_fold);",
      "    }",
      "};"
    ],
    "description": "heavy_path_decomposition"
  },
  "poset_width": {
    "prefix": "poset_width",
    "body": [
      "vi width(vector<vi> poset) {",
      "    int N = poset.size();",
      "    bipartite_graph g(N, N);",
      "",
      "    for (int i = 0; i < N; i++) {",
      "        for (int j : poset[i])",
      "            g.edge(j, i);",
      "    }",
      "",
      "    g.matching();",
      "",
      "    vb vis[2];",
      "    vis[false].resize(2 * N, false);",
      "    vis[true].resize(2 * N, false);",
      "",
      "    for (int i = 0; i < N; i++) {",
      "        if (g.match[i] != -1) continue;",
      "        if (vis[false][i]) continue;",
      "",
      "        queue<pair<bool, int>> bfs;",
      "        bfs.push(make_pair(false, i));",
      "        vis[false][i] = true;",
      "",
      "        while (!bfs.empty()) {",
      "            bool inm = bfs.front().first;",
      "            int loc = bfs.front().second;",
      "            bfs.pop();",
      "",
      "            for (int nbr : g.adj[loc]) {",
      "                if (vis[!inm][nbr]) continue;",
      "                if ((g.match[loc] == nbr) ^ inm) continue;",
      "",
      "                vis[!inm][nbr] = true;",
      "                bfs.push(make_pair(!inm, nbr));",
      "            }",
      "        }",
      "    }",
      "",
      "    vb inz(2 * N, false);",
      "    for (int i = 0; i < 2 * N; i++)",
      "        inz[i] = vis[true][i] || vis[false][i];",
      "",
      "    vb ink(N, false);",
      "",
      "    for (int i = 0; i < N; i++)",
      "        if (!inz[i])",
      "            ink[i]= true;",
      "",
      "    for (int i = N; i < 2 * N; i++)",
      "        if (inz[i])",
      "            ink[i - N] = true;",
      "",
      "    vi res;",
      "    for (int i = 0; i < N; i++) {",
      "        if (!ink[i])",
      "            res.push_back(i);",
      "    }",
      "    return res;",
      "}",
      ""
    ],
    "description": "poset_width"
  },
  "min_cost_vertex_cover": {
    "prefix": "min_cost_vertex_cover",
    "body": [
      "#include <vector>",
      "#include <limits>",
      "#include <cstdint>",
      "",
      "template<typename cost_t, typename sum_t>",
      "sum_t min_cost_vertex_cover(int V, std::vector<cost_t> cost, std::vector<int64_t> adj) {",
      "    const sum_t INF = std::numeric_limits<sum_t>::max() / 2;",
      "    auto generate = [&](const int offset, const int ct) {",
      "        std::vector<sum_t> v(1 << ct);",
      "",
      "        for (int m = 1; m < int(v.size()); m++) {",
      "            int i = __builtin_ctz(m);",
      "            v[m] = v[m ^ (1 << i)] + cost[offset + i];",
      "        }",
      "",
      "        for (int m = 0; m < int(v.size()); m++) {",
      "            int64_t need = 0;",
      "            for (int i = 0; i < ct; i++) {",
      "                if (!(m & (1 << i))) {",
      "                    need |= adj[offset + i];",
      "                }",
      "            }",
      "            need >>= offset;",
      "            need &= (1 << ct) - 1;",
      "",
      "            if ((m & need) != need) {",
      "                v[m] = INF;",
      "            }",
      "        }",
      "",
      "        for (int i = 0; i < ct; i++) {",
      "            for (int m = 0; m < int(v.size()); m++) {",
      "                if (!(m & (1 << i))) {",
      "                    v[m] = std::min(v[m], v[m ^ (1 << i)]);",
      "                }",
      "            }",
      "        }",
      "",
      "        return v;",
      "    };",
      "",
      "    const int L = (V + 1) / 2;",
      "    const int R = V / 2;",
      "",
      "    auto f = generate(0, L);",
      "    auto g = generate(L, R);",
      "",
      "    sum_t ans = INF;",
      "",
      "    for (int m = 0; m < (1 << L); m++) {",
      "        int64_t need = 0;",
      "        for (int i = 0; i < L; i++) {",
      "            if (!(m & (1 << i))) {",
      "                need |= adj[i];",
      "            }",
      "        }",
      "",
      "        int left = int(need & ((1 << L) - 1));",
      "        if ((m & left) != left) {",
      "            continue;",
      "        }",
      "",
      "        int right = int(need >> L);",
      "        ans = std::min(ans, f[m] + g[right]);",
      "    }",
      "",
      "    return ans;",
      "}"
    ],
    "description": "min_cost_vertex_cover"
  },
  "condensed_tree": {
    "prefix": "condensed_tree",
    "body": [
      "template<typename E> struct condensed_tree {",
      "    const lowest_common_ancestor<E>& t;",
      "    vi label, above; vb interesting; int root, L;",
      "",
      "    condensed_tree(const lowest_common_ancestor<E>& _t, vi points_of_interest,",
      "            int _root = -1) : t(_t), label(_t.t.V, -1), interesting(_t.t.V, 0), root(_root), L(0) {",
      "        sort_by(points_of_interest, t.first_visit[a] < t.first_visit[b]);",
      "        unique(all(points_of_interest));",
      "        for (int i = 0; i < sz(points_of_interest); i++) {",
      "            interesting[points_of_interest[i]] = true;",
      "            if (i) interesting[t.lca(points_of_interest[i-1], points_of_interest[i])] = true;",
      "        }",
      "        if (root != -1) interesting[root] = true;",
      "",
      "        for (int u : t.preorder) if (interesting[u]) {",
      "            label[u] = L;",
      "            int v = t.par(u);",
      "            if (v == -1 || interesting[v]) {",
      "                above.pb(v != -1 ? label[v] : -1), L++;",
      "                continue;",
      "            }",
      "            if (root == -1) above.pb(++L);",
      "            for (; v != -1 && !interesting[v]; v = t.par(v))",
      "                label[v] = L;",
      "            above.pb(v != -1 ? label[v] : -1), L++;",
      "        }",
      "    }",
      "",
      "    const vi& decompose_path(int u, int v, bool include_lca) const {",
      "        static vi res; res.clear();",
      "        int w = t.lca(u, v); if (root != -1) assert(root == w);",
      "        assert(interesting[u] && interesting[v] && interesting[w]);",
      "        for (int x = label[u]; x != label[w]; x = above[x]) res.pb(x);",
      "        if (include_lca) res.pb(label[w]);",
      "        size_t bef = res.size();",
      "        for (int x = label[v]; x != label[w]; x = above[x]) res.pb(x);",
      "        reverse(res.begin() + bef, res.end());",
      "        return res;",
      "    }",
      "",
      "    template<typename F>",
      "    void for_each_label_commutative(int u, int v, bool include_lca, F f) const {",
      "        int w = t.lca(u, v); if (root != -1) assert(root == w);",
      "        assert(interesting[u] && interesting[v] && interesting[w]);",
      "        for (int x = label[u]; x != label[w]; x = above[x]) f(x);",
      "        if (include_lca) f(label[w]);",
      "        for (int x = label[v]; x != label[w]; x = above[x]) f(x);",
      "    }",
      "};"
    ],
    "description": "condensed_tree"
  },
  "lca_jump_pointers": {
    "prefix": "lca_jump_pointers",
    "body": [
      "/*",
      " * Supports O(logN) lowest common ancestor queries on an immutable tree.",
      " */",
      "struct lowest_common_ancestor_log {",
      "    int L, N;",
      "    vi depth, link;",
      "",
      "    lowest_common_ancestor_log() { }",
      "",
      "    lowest_common_ancestor_log(const vvi &graph, int root = 0) : N(graph.size()) {",
      "        L = 32 - __builtin_clz(N);",
      "        depth.resize(N);",
      "        link.resize(L*N);",
      "        init(root, root, graph);",
      "    }",
      "",
      "    /*",
      "     * Initializes the link table in O(NlogN). link[l * N + i] contains the index",
      "     * of the (2 ** l)th ancestor of vertex i.",
      "     */",
      "    void init(int loc, int par, const vvi &graph) {",
      "        link[loc] = par;",
      "        for (int l = 1; l < L; l++)",
      "            link[l*N + loc] = link[(l-1)*N + link[(l-1)*N + loc]];",
      "",
      "        for (int nbr : graph[loc]) if (nbr != par) {",
      "            depth[nbr] = depth[loc] + 1;",
      "            init(nbr, loc, graph);",
      "        }",
      "    }",
      "",
      "    // Returns the index of the dist-th ancestor of vertex loc in O(logN).",
      "    int above(int loc, int dist) {",
      "        dist = min(dist, N - 1);",
      "        for (int l = 0; l < L; l++)",
      "            if (dist & (1 << l))",
      "                loc = link[l*N + loc];",
      "        return loc;",
      "    }",
      "",
      "    // Returns the least common ancestor of vertices u and v in O(logN).",
      "    int lca(int u, int v) {",
      "        if (depth[u] > depth[v]) swap(u, v);",
      "        v = above(v, depth[v] - depth[u]);",
      "        if (u == v) return u;",
      "",
      "        for (int l = L - 1; l >= 0; l--) {",
      "            if (link[l*N + u] != link[l*N + v])",
      "                u = link[l*N + u], v = link[l*N + v];",
      "        }",
      "        return link[u];",
      "    }",
      "",
      "    int dist(int u, int v) {",
      "        return depth[u] + depth[v] - 2 * depth[lca(u, v)];",
      "    }",
      "",
      "    bool on_path(int u, int v, int inx) {",
      "        return dist(u, v) == dist(u, inx) + dist(inx, v);",
      "    }",
      "};"
    ],
    "description": "lca_jump_pointers"
  },
  "bipartite_graph": {
    "prefix": "bipartite_graph",
    "body": [
      "struct bipartite_graph {",
      "    int A, B;",
      "    vvi adj;",
      "",
      "    bipartite_graph(int _A, int _B) {",
      "        A = _A, B = _B;",
      "        adj.resize(A + B);",
      "    }",
      "",
      "    void edge(int i, int j) {",
      "        adj[i].push_back(A+j);",
      "        adj[A+j].push_back(i);",
      "    }",
      "",
      "    vi visit, match;",
      "",
      "    bool augment(int loc, int run) {",
      "        if(visit[loc] == run) return false;",
      "        visit[loc] = run;",
      "",
      "        for (int nbr : adj[loc]) {",
      "            if (match[nbr] == -1 || augment(match[nbr], run)) {",
      "                match[loc] = nbr, match[nbr] = loc;",
      "                return true;",
      "            }",
      "        }",
      "",
      "        return false;",
      "    }",
      "",
      "    int matching() {",
      "        visit = vi(A+B, -1);",
      "        match = vi(A+B, -1);",
      "",
      "        int ans = 0;",
      "        for (int i = 0; i < A; i++)",
      "            ans += augment(i, i);",
      "        return ans;",
      "    }",
      "",
      "    vector<bool> vertex_cover() {",
      "        vector<bool> res(A + B, false);",
      "        queue<int> bfs;",
      "",
      "        for (int i = 0; i < A; i++) {",
      "            if (match[i] == -1) bfs.push(i);",
      "            else res[i] = true;",
      "        }",
      "",
      "        while (!bfs.empty()) {",
      "            int loc = bfs.front();",
      "            bfs.pop();",
      "            for (int nbr : adj[loc]) {",
      "                if (res[nbr]) continue;",
      "                res[nbr] = true;",
      "                int loc2 = match[nbr];",
      "                if (loc2 == -1) continue;",
      "                res[loc2] = false;",
      "                bfs.push(loc2);",
      "            }",
      "        }",
      "",
      "        return res;",
      "    }",
      "};",
      ""
    ],
    "description": "bipartite_graph"
  },
  "chain_decomposition": {
    "prefix": "chain_decomposition",
    "body": [
      "template<typename E> struct chain_decomposition {",
      "    const graph<E>& g;",
      "",
      "    vvi chains;",
      "    vb artp, bridge;",
      "",
      "    chain_decomposition(const graph<E>& _g) : g(_g) {",
      "        vi dfs_order, dfs_index(g.V, -1), parent_edge(g.V, -1);",
      "        vector<vector<reference_wrapper<const E>>> back_edges(g.V);",
      "",
      "        vb seen_edge(g.EC, false);",
      "        auto dfs = [&](auto& self, int u) -> void {",
      "            dfs_index[u] = sz(dfs_order);",
      "            dfs_order.pb(u);",
      "            for (const E& e : g.edges[u]) if (!seen_edge[e.i]) {",
      "                seen_edge[e.i] = true;",
      "                if (dfs_index[e[u]] == -1) {",
      "                    parent_edge[e[u]] = e.i;",
      "                    self(self, e[u]);",
      "                } else back_edges[e[u]].pb(e);",
      "            }",
      "        };",
      "        for (int u = 0; u < g.V; u++) if (dfs_index[u] == -1) dfs(dfs, u);",
      "",
      "        artp.resize(g.V, false);",
      "        bridge.resize(g.EC, true);",
      "",
      "        vb visited(g.V, false);",
      "        for (int u : dfs_order) for (const E& e : back_edges[u]) {",
      "            chains.pb({e.i});",
      "            int v = e[u];",
      "            for (visited[u] = true; !visited[v]; ) {",
      "                visited[v] = true;",
      "                chains.back().pb(parent_edge[v]);",
      "                v = g.edge_list[parent_edge[v]][v];",
      "            }",
      "            for (int edge_index : chains.back()) bridge[edge_index] = false;",
      "            if (sz(chains) > 1 && u == v) artp[u] = true;",
      "        }",
      "",
      "        for (const E& e : g.edge_list) if (bridge[e.i]) {",
      "            if (sz(g.nbrs[e.u]) >= 2) artp[e.u] = true;",
      "            if (sz(g.nbrs[e.v]) >= 2) artp[e.v] = true;",
      "        }",
      "    }",
      "",
      "    bool is_articulation_point(int vertex) const {",
      "        return artp[vertex];",
      "    }",
      "    bool is_bridge(int edge_index) const {",
      "        return bridge[edge_index];",
      "    }",
      "};"
    ],
    "description": "chain_decomposition"
  },
  "lowest_common_ancestor": {
    "prefix": "lowest_common_ancestor",
    "body": [
      "// {{{ graphs/tree.cpp }}}",
      "// {{{ data_structures/sparse_table.cpp }}}",
      "",
      "#include <vector>",
      "",
      "template<typename Edge>",
      "struct lowest_common_ancestor {",
      "    const tree<Edge>& t;",
      "",
      "    std::vector<int> euler_tour, tour_depths, first_visit, last_visit;",
      "",
      "    int operator()(int i, int j) const {",
      "        // if two visits have equal depth we prefer the later, allowing us to compute first_step",
      "        return tour_depths[i] < tour_depths[j] ? i : j;",
      "    }",
      "",
      "    sparse_table<int, const lowest_common_ancestor<Edge>&> tour_table;",
      "",
      "    lowest_common_ancestor() {}",
      "",
      "    lowest_common_ancestor(const tree<Edge>& _t) : t(_t), first_visit(t.V), last_visit(t.V), tour_table(*this) {",
      "        record_tour(t.root);",
      "        tour_table.construct(int(euler_tour.size()), [](int i) { return i; });",
      "    }",
      "",
      "    void record_tour(int u) {",
      "        first_visit[u] = int(euler_tour.size());",
      "        euler_tour.push_back(u);",
      "        tour_depths.push_back(t.depth[u]);",
      "",
      "        t.for_each_child(u, [&](const Edge& e) {",
      "            record_tour(e.get_nbr(u));",
      "            euler_tour.push_back(u);",
      "            tour_depths.push_back(t.depth[u]);",
      "        });",
      "",
      "        last_visit[u] = int(euler_tour.size()) - 1;",
      "    }",
      "",
      "    int lca(int u, int v) const {",
      "        u = first_visit[u], v = first_visit[v];",
      "        if (u > v) std::swap(u, v);",
      "        return euler_tour[tour_table.accumulate(u, v + 1)];",
      "    }",
      "",
      "    int dist(int u, int v) const {",
      "        return t.depth[u] + t.depth[v] - 2 * t.depth[lca(u, v)];",
      "    }",
      "",
      "    bool uv_path_has_w(int u, int v, int w) const {",
      "        return w != -1 && dist(u, v) == (dist(u, w) + dist(w, v));",
      "    }",
      "",
      "    bool is_ancestor(int anc, int desc) const {",
      "        return first_visit[anc] <= first_visit[desc] && first_visit[desc] <= last_visit[anc];",
      "    }",
      "",
      "    // Returns the neighbor of u on the simple path from u to v",
      "    int first_step(int u, int v) const {",
      "        assert(u != v);",
      "        if (!is_ancestor(u, v)) return t.parent[u];",
      "        return euler_tour[tour_table.accumulate(first_visit[u], first_visit[v]) + 1];",
      "    }",
      "};"
    ],
    "description": "lowest_common_ancestor"
  },
  "tree_isomorphism": {
    "prefix": "tree_isomorphism",
    "body": [
      "    void collect_by_depth(vvi& d, int u, bool avoid_erased, int p = -1, int d0 = 0) const {",
      "        if (d0 >= sz(d)) d.resize(d0 + 1);",
      "        d[d0].push_back(u);",
      "        for (int v : nbrs[u]) if (v != p && (!avoid_erased || !erased[v])) {",
      "            collect_by_depth(d, v, avoid_erased, u, d0+1);",
      "        }",
      "    }",
      "",
      "    friend bool rooted_iso(const tree<E>& a, int ra,",
      "                           const tree<E>& b, int rb, bool avoid_erased = 1) {",
      "        vvi abd, bbd;",
      "        a.collect_by_depth(abd, ra, avoid_erased);",
      "        b.collect_by_depth(bbd, rb, avoid_erased);",
      "        if (sz(abd) != sz(bbd)) return false;",
      "",
      "        int D = sz(abd);",
      "        vi alb, blb;",
      "        for (int d = D - 1; d >= 0; d--) {",
      "            vi &al = abd[d], &bl = bbd[d];",
      "            sort(all(al)), sort(all(bl));",
      "            int L = sz(al); if (L != sz(bl)) return false;",
      "",
      "            vector<pair<vi, int>> ac(L), bc(L);",
      "            if (d + 1 < D) {",
      "                const vi &na = abd[d+1], &nb = bbd[d+1];",
      "                for (int i = 0; i < L; i++) {",
      "                    ac[i].s = bc[i].s = i;",
      "                    for (int n : a.nbrs[al[i]]) {",
      "                        auto it = lb(all(na), n);",
      "                        if (it != na.end() && *it == n)",
      "                            ac[i].f.pb(alb[it - na.begin()]);",
      "                    }",
      "                    for (int n : b.nbrs[bl[i]]) {",
      "                        auto it = lb(all(nb), n);",
      "                        if (it != nb.end() && *it == n)",
      "                            bc[i].f.pb(blb[it - nb.begin()]);",
      "                    }",
      "                    sort(all(ac[i].f)), sort(all(bc[i].f));",
      "                }",
      "            }",
      "            sort(all(ac)), sort(all(bc));",
      "",
      "            alb.resize(sz(ac)), blb.resize(sz(bc));",
      "            if (d + 1 < D) for (int i = 0, j = 0; i < sz(ac); i++) {",
      "                if (ac[i].f != bc[i].f) return false;",
      "                if (i && (ac[i].f != ac[i-1].f)) j++;",
      "                alb[ac[i].s] = blb[bc[i].s] = j;",
      "            }",
      "        }",
      "",
      "        return true;",
      "    }",
      "",
      "    friend bool iso(const tree<E>& a, int ra,",
      "                    const tree<E>& b, int rb, bool avoid_erased = 1) {",
      "        int ca = a.centroids(ra, avoid_erased)[0];",
      "        for (int cb : b.centroids(rb, avoid_erased))",
      "            if (rooted_iso(a, ca, b, cb, avoid_erased))",
      "                return true;",
      "        return false;",
      "    }",
      "    friend bool iso(const tree<E>& a, const tree<E>& b) {",
      "        return iso(a, 0, b, 0, 0);",
      "    }"
    ],
    "description": "tree_isomorphism"
  },
  "mutable_string_bitset": {
    "prefix": "mutable_string_bitset",
    "body": [
      "#include <vector>",
      "#include <bitset>",
      "",
      "#pragma GCC optimize(\"unroll-loops\")",
      "#pragma GCC target(\"popcnt,tune=native\")",
      "",
      "template<int MIN_CHAR, int SIGMA, int MAX_LEN>",
      "struct mutable_string_bitset {",
      "    std::vector<std::bitset<MAX_LEN>> occur;",
      "",
      "    template<typename InputIterator>",
      "    mutable_string_bitset(InputIterator first, InputIterator last) : occur(SIGMA) {",
      "        int i = 0;",
      "        for (InputIterator iter = first; iter != last; iter++)",
      "            occur[*iter - MIN_CHAR][i++] = true;",
      "    }",
      "",
      "    void assign(int i, int c) {",
      "        for (int a = 0; a < SIGMA; a++)",
      "            occur[a][i] = false;",
      "        occur[c - MIN_CHAR][i] = true;",
      "    }",
      "",
      "    /* Counts occurrences of the pattern [first, last) within the substring [L, R)",
      "     * O(|last - first| * MAX_LEN / MACHINE_WORD_SIZE)",
      "     */",
      "    template<typename InputIterator>",
      "    int count_matches(InputIterator first, InputIterator last, int L = 0, int R = MAX_LEN) const {",
      "        static std::bitset<MAX_LEN> match;",
      "        match.set(); // sets all bits to true",
      "",
      "        int i = 0;",
      "        for (InputIterator iter = first; iter != last; iter++)",
      "            match &= occur[*iter - MIN_CHAR] >> (i++);",
      "",
      "        int count = 0;",
      "",
      "        int min_pos = L, max_pos = R - i + 1;",
      "",
      "        while (min_pos < max_pos && min_pos % 64)",
      "            count += match[min_pos++];",
      "",
      "        while (min_pos < max_pos && max_pos % 64)",
      "            count += match[--max_pos];",
      "",
      "        static uint64_t *data = (uint64_t*)&match;",
      "        for (int inx = min_pos / 64; inx < max_pos / 64; inx++)",
      "            count += __builtin_popcountll(data[inx]);",
      "",
      "        return count;",
      "    }",
      "};"
    ],
    "description": "mutable_string_bitset"
  },
  "palindromes": {
    "prefix": "palindromes",
    "body": [
      "// {{{ data_structures/sparse_table.cpp }}}",
      "",
      "#include <vector>",
      "#include <cassert>",
      "",
      "struct palindromes {",
      "    int SZ;",
      "    std::vector<int> width;",
      "",
      "    template<typename I>",
      "    palindromes(I begin, I end) {",
      "        SZ = int(end - begin);",
      "        width.resize(std::max(2 * SZ - 1, 0));",
      "",
      "        auto match = [&](int c, int r) {",
      "            if ((c - r) < -1 || (c + r) > int(width.size())) return false;",
      "            return (c - r)&1 || *(begin + (c - r)/2) == *(begin + (c + r)/2);",
      "        };",
      "",
      "        for (int cen = 0, lim = -1, ref; cen < int(width.size()); cen++) {",
      "            if (lim > cen)",
      "                width[cen] = std::min(width[2 * ref - cen], lim - cen);",
      "            while (match(cen, width[cen] + 1))",
      "                width[cen]++;",
      "            if (cen + width[cen] > lim) {",
      "                lim = cen + width[cen];",
      "                ref = cen;",
      "            }",
      "        }",
      "    }",
      "",
      "    int longest_centered_at(int index) const {",
      "        assert(0 <= index && index < SZ);",
      "        return width[2 * index];",
      "    }",
      "",
      "    int longest_centered_right_of(int index) const {",
      "        assert(0 <= index && index < SZ - 1);",
      "        return width[2 * index + 1];",
      "    }",
      "",
      "    int longest_within_substring(int pos, int len) const {",
      "        static sparse_table<int>",
      "            width_rmq(int(width.size()), std::max<int>, [&](int i) { return width[i]; });",
      "",
      "        assert(0 <= pos && pos + len <= SZ);",
      "",
      "        int lo = 0, hi = len + 1;",
      "        while (hi - lo > 1) {",
      "            int mi = lo + (hi - lo) / 2;",
      "            int min_c = std::min(2 * (pos + mi / 2), 2 * (pos + (mi - 2 + 1) / 2) + 1);",
      "            int max_c = std::max(2 * (pos + len - mi / 2) - 1, 2 * (pos + len - (mi + 1) / 2));",
      "            if (min_c < max_c && width_rmq.accumulate(min_c, max_c) >= mi)",
      "                lo = mi;",
      "            else",
      "                hi = mi;",
      "        }",
      "        return lo;",
      "    }",
      "};"
    ],
    "description": "palindromes"
  },
  "z_algorithm": {
    "prefix": "z_algorithm",
    "body": [
      "#include <vector>",
      "",
      "/* Returns z[i] = the greatest length L such that",
      " * s[i, i+L) is identical to s[0, L).",
      " */",
      "template<typename RandomAccessIterator>",
      "std::vector<int> z_algorithm(RandomAccessIterator first, RandomAccessIterator last) {",
      "    int N = int(last - first);",
      "",
      "    std::vector<int> z(N);",
      "    z[0] = N;",
      "",
      "    for (int i = 1, l, r = -1; i < N; i++) {",
      "        z[i] = r > i ? std::min(r - i, z[i - l]) : 0;",
      "        while (i + z[i] < N && first[i + z[i]] == first[z[i]])",
      "            z[i]++;",
      "        if (i + z[i] > r)",
      "            l = i, r = i + z[i];",
      "    }",
      "",
      "    return z;",
      "};"
    ],
    "description": "z_algorithm"
  },
  "knuth_morris_pratt": {
    "prefix": "knuth_morris_pratt",
    "body": [
      "#include <vector>",
      "",
      "struct knuth_morris_pratt {",
      "    int SZ;",
      "    std::vector<int> pattern;",
      "    std::vector<int> suffix_link;",
      "",
      "    int append(int matched, int c) const {",
      "        while (matched > 0 && pattern[matched] != c)",
      "            matched = suffix_link[matched];",
      "        return matched + int(pattern[matched] == c);",
      "    }",
      "",
      "    knuth_morris_pratt() : SZ(0) { }",
      "",
      "    template<typename InputIterator>",
      "    knuth_morris_pratt(InputIterator begin, InputIterator end) {",
      "        initialize(begin, end);",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    void initialize(InputIterator begin, InputIterator end) {",
      "        pattern.resize(end - begin);",
      "        copy(begin, end, pattern.begin());",
      "",
      "        SZ = int(pattern.size());",
      "        suffix_link.resize(SZ + 1);",
      "",
      "        for (int matched = 1; matched < SZ; matched++)",
      "            suffix_link[matched + 1] = append(suffix_link[matched], pattern[matched]);",
      "    }",
      "",
      "    template<typename InputIterator, typename F>",
      "    void find_matches(InputIterator begin, InputIterator end, F consume) const {",
      "        int i = 0;",
      "        int matched = 0;",
      "        for (InputIterator iter = begin; iter != end; iter++, i++) {",
      "            matched = append(matched, *iter);",
      "            if (matched == SZ) {",
      "                consume(i - SZ + 1);",
      "                matched = suffix_link[matched];",
      "            }",
      "        }",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    int count_matches(InputIterator begin, InputIterator end) const {",
      "        int count = 0;",
      "        find_matches(begin, end, [&](__attribute((unused))int index) { count++; });",
      "        return count;",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    std::vector<int> indices_of_matches(InputIterator begin, InputIterator end) const {",
      "        std::vector<int> indices;",
      "        find_matches(begin, end, [&](int index) { indices.push_back(index); });",
      "        return indices;",
      "    }",
      "};"
    ],
    "description": "knuth_morris_pratt"
  },
  "suffix_automaton": {
    "prefix": "suffix_automaton",
    "body": [
      "// {{{ misc/stable_counting_sort.cpp }}}",
      "",
      "#include <array>",
      "#include <vector>",
      "#include <cassert>",
      "",
      "template<int MIN_CHAR, int SIGMA>",
      "struct suffix_automaton {",
      "    struct state {",
      "        int len = 0;",
      "        int suffix_link = -1;",
      "        int first_end_pos = -1;",
      "        std::array<int, SIGMA> transitions;",
      "        state() { transitions.fill(-1); }",
      "    };",
      "",
      "    int SZ, last;",
      "    std::vector<state> data;",
      "    std::vector<bool> is_clone;",
      "",
      "    const state& operator [] (int loc) const { return data[loc]; }",
      "",
      "    int create_state(state s = {}) {",
      "        data.push_back(s);",
      "        is_clone.push_back(s.len != 0);",
      "        return int(data.size()) - 1;",
      "    }",
      "",
      "    suffix_automaton() : SZ(0) { last = create_state(); }",
      "",
      "    template<typename InputIterator>",
      "    suffix_automaton(InputIterator begin, InputIterator end) {",
      "        initialize(begin, end);",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    void initialize(InputIterator begin, InputIterator end) {",
      "        SZ = 0;",
      "        data.clear();",
      "        is_clone.clear();",
      "        last = create_state();",
      "",
      "        for (InputIterator iter = begin; iter != end; iter++)",
      "            append(*iter);",
      "        initialize_auxiliary_data();",
      "    }",
      "",
      "    void append(int c) {",
      "        assert(MIN_CHAR <= c && c < MIN_CHAR + SIGMA);",
      "        c -= MIN_CHAR;",
      "",
      "        int p = last;",
      "",
      "        last = create_state();",
      "        data[last].first_end_pos = SZ;",
      "        data[last].len = ++SZ;",
      "",
      "        while (p != -1 && data[p].transitions[c] == -1) {",
      "            data[p].transitions[c] = last;",
      "            p = data[p].suffix_link;",
      "        }",
      "",
      "        if (p == -1) {",
      "            data[last].suffix_link = 0;",
      "            return;",
      "        }",
      "",
      "        int q = data[p].transitions[c];",
      "        if (data[q].len - data[p].len == 1) {",
      "            data[last].suffix_link = q;",
      "            return;",
      "        }",
      "",
      "        int pc = create_state(data[q]);",
      "        data[pc].len = data[p].len + 1;",
      "",
      "        while (p != -1 && data[p].transitions[c] == q) {",
      "            data[p].transitions[c] = pc;",
      "            p = data[p].suffix_link;",
      "        }",
      "",
      "        data[q].suffix_link = pc;",
      "        data[last].suffix_link = pc;",
      "    }",
      "",
      "    std::vector<int> reverse_length_order;",
      "    std::vector<int> ct_end_pos;",
      "    void initialize_auxiliary_data() {",
      "        reverse_length_order = stable_counting_sort::permutation(",
      "                int(data.size()), SZ + 1, [&](int loc) { return SZ - data[loc].len; });",
      "",
      "        ct_end_pos.assign(data.size(), 0);",
      "        for (int loc : reverse_length_order) {",
      "            if (loc) {",
      "                ct_end_pos[loc] += !is_clone[loc];",
      "                ct_end_pos[data[loc].suffix_link] += ct_end_pos[loc];",
      "            } else ct_end_pos[loc] = 0;",
      "        }",
      "    }",
      "",
      "    int transition(int loc, int c) const {",
      "        assert(loc != -1 && MIN_CHAR <= c && c < MIN_CHAR + SIGMA);",
      "        return data[loc].transitions[c - MIN_CHAR];",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    int state_associated_with(InputIterator begin, InputIterator end) const {",
      "        int loc = 0;",
      "        for (auto iter = begin; iter != end && loc != -1; iter++)",
      "            loc = transition(loc, *iter);",
      "        return loc;",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    int first_occurrence(InputIterator begin, InputIterator end) const {",
      "        int loc = state_associated_with(begin, end);",
      "        return loc == -1 ? -1 : data[loc].first_end_pos - distance(begin, end) + 1;",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    int count_occurrences(InputIterator begin, InputIterator end) const {",
      "        int loc = state_associated_with(begin, end);",
      "        return loc == -1 ? 0 : ct_end_pos[loc];",
      "    }",
      "};"
    ],
    "description": "suffix_automaton"
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "#include <array>",
      "#include <vector>",
      "#include <cassert>",
      "#include <queue>",
      "",
      "template<int MIN_CHAR, int SIGMA>",
      "struct trie {",
      "    struct node {",
      "        int depth;",
      "        std::array<int, SIGMA> child_links;",
      "",
      "        int dict_index = -1;",
      "",
      "        int suffix_link = 0;",
      "        int dict_suffix_link = 0;",
      "        int count_suffixes_in_dict = 0;",
      "",
      "        node(int depth_) : depth(depth_) {",
      "            child_links.fill(0);",
      "        }",
      "    };",
      "",
      "    std::vector<node> data;",
      "    std::vector<int> dictionary_word_links;",
      "",
      "    int& child_link(int loc, int c) { return data[loc].child_links[c - MIN_CHAR]; }",
      "    int child_link(int loc, int c) const { return data[loc].child_links[c - MIN_CHAR]; }",
      "",
      "    int dict_proper_suffix_link(int loc) const {",
      "        return data[data[loc].suffix_link].dict_suffix_link;",
      "    }",
      "",
      "    trie() : data(1, node(0)) {}",
      "",
      "    template<typename InputIterator>",
      "    trie(InputIterator first, InputIterator last) : data(1, node(0)) {",
      "        for (InputIterator iter = first; iter != last; iter++)",
      "            add_dictionary_word(iter->begin(), iter->end());",
      "        build_suffix_link_tree();",
      "    }",
      "",
      "private:",
      "",
      "    template<typename InputIterator>",
      "    void add_dictionary_word(InputIterator first, InputIterator last) {",
      "        int loc = 0;",
      "        for (InputIterator iter = first; iter != last; iter++) {",
      "            int c = *iter;",
      "            assert(MIN_CHAR <= c && c < MIN_CHAR + SIGMA);",
      "",
      "            if (!child_link(loc, c)) {",
      "                child_link(loc, c) = int(data.size());",
      "                data.push_back(node(data[loc].depth + 1));",
      "            }",
      "            loc = child_link(loc, c);",
      "        }",
      "        if (data[loc].count_suffixes_in_dict == 0) {",
      "            data[loc].dict_suffix_link = loc;",
      "            data[loc].dict_index = int(dictionary_word_links.size());",
      "        }",
      "        data[loc].count_suffixes_in_dict++;",
      "        dictionary_word_links.push_back(loc);",
      "    }",
      "",
      "    std::vector<std::vector<int>> children;",
      "    std::vector<std::pair<int, int>> dfs_ranges;",
      "    void build_suffix_link_tree() {",
      "        children.resize(int(data.size()));",
      "",
      "        std::queue<int> bfs;",
      "        for (int child : data[0].child_links)",
      "            if (child) bfs.push(child);",
      "        for (; !bfs.empty(); bfs.pop()) {",
      "            int loc = bfs.front();",
      "            int parent = data[loc].suffix_link;",
      "",
      "            children[parent].push_back(loc);",
      "            if (data[loc].dict_suffix_link == 0)",
      "                data[loc].dict_suffix_link = data[parent].dict_suffix_link;",
      "            data[loc].count_suffixes_in_dict += data[parent].count_suffixes_in_dict;",
      "",
      "            for (int c = MIN_CHAR; c < MIN_CHAR + SIGMA; c++) {",
      "                int &trie_child = child_link(loc, c);",
      "                if (trie_child) {",
      "                    bfs.push(trie_child);",
      "                    data[trie_child].suffix_link = child_link(parent, c);",
      "                } else trie_child = child_link(parent, c);",
      "            }",
      "        }",
      "",
      "        dfs_ranges.resize(data.size());",
      "",
      "        int visited = 0;",
      "        auto dfs = [&](auto self, int loc) -> void {",
      "            dfs_ranges[loc].first = visited++;",
      "            for (int child : children[loc])",
      "                self(self, child);",
      "            dfs_ranges[loc].second = visited;",
      "        };",
      "        dfs(dfs, 0);",
      "    }",
      "",
      "    template<typename V>",
      "    void copy_results_for_duplicate_dictionary_entries(std::vector<V> &results) const {",
      "        for (int dict_index = 0; dict_index < int(dictionary_word_links.size()); dict_index++) {",
      "            int loc = dictionary_word_links[dict_index];",
      "            if (data[loc].dict_index != dict_index)",
      "                results[dict_index] = results[data[loc].dict_index];",
      "        }",
      "    }",
      "",
      "public:",
      "",
      "    /* Processes the given text and returns the number of matches of each dictionary word.",
      "     * Linear in text length and the number of dictionary words.",
      "     */",
      "    template<typename InputIterator>",
      "    std::vector<int> count_matches(InputIterator first, InputIterator last) const {",
      "        std::vector<int> count(dictionary_word_links.size());",
      "        std::vector<std::vector<int>> found_with_length;",
      "",
      "        auto record_match = [&](int loc, int quantity) {",
      "            int dict_index = data[loc].dict_index;",
      "            if (dict_index == -1) return;",
      "",
      "            if (count[dict_index] == 0) {",
      "                if (data[loc].depth >= int(found_with_length.size()))",
      "                    found_with_length.resize(data[loc].depth + 1);",
      "                found_with_length[data[loc].depth].push_back(loc);",
      "            }",
      "            count[dict_index] += quantity;",
      "        };",
      "",
      "        int loc = 0;",
      "        for (InputIterator iter = first; iter != last; iter++) {",
      "            int c = *iter;",
      "            assert(MIN_CHAR <= c && c < MIN_CHAR + SIGMA);",
      "",
      "            loc = child_link(loc, c);",
      "            record_match(data[loc].dict_suffix_link, 1);",
      "        }",
      "",
      "        for (int match_length = int(found_with_length.size()) - 1; match_length > 0; match_length--) {",
      "            for (int match_loc : found_with_length[match_length])",
      "                record_match(dict_proper_suffix_link(match_loc), count[data[match_loc].dict_index]);",
      "        }",
      "",
      "        copy_results_for_duplicate_dictionary_entries(count);",
      "        return count;",
      "    }",
      "",
      "    /* Returns the starting index of every match of each dictionary word.",
      "     * Linear in the text length, number of dictionary words, and total number of matches.",
      "     */",
      "    template<typename InputIterator>",
      "    std::vector<std::vector<int>> indices_of_matches(InputIterator first, InputIterator last) const {",
      "        std::vector<std::vector<int>> indices(int(dictionary_word_links.size()));",
      "",
      "        int loc = 0;",
      "        int index = 0;",
      "        for (InputIterator iter = first; iter != last; iter++, index++) {",
      "            int c = *iter;",
      "            assert(MIN_CHAR <= c && c < MIN_CHAR + SIGMA);",
      "",
      "            loc = child_link(loc, c);",
      "            for (int par = data[loc].dict_suffix_link; par != 0; par = dict_proper_suffix_link(par)) {",
      "                indices[data[par].dict_index].push_back(index + 1 - data[par].depth);",
      "            }",
      "        }",
      "",
      "        /* Notable fact: before duplication, the total number of matches is at most",
      "         * (text length) * (number of distinct dictionary word lengths), which is",
      "         * O(text length * sqrt(sum of dictionary word lengths)).",
      "         */",
      "        copy_results_for_duplicate_dictionary_entries(indices);",
      "        return indices;",
      "    }",
      "",
      "    /* Returns the total number of matches over all dictionary words.",
      "     * Duplicate dictionary entries each contribute to the total match count.",
      "     * Linear in the text length.",
      "     */",
      "    template<typename InputIterator>",
      "    int64_t count_total_matches(InputIterator first, InputIterator last) const {",
      "        int64_t count = 0;",
      "",
      "        int loc = 0;",
      "        for (InputIterator iter = first; iter != last; iter++) {",
      "            int c = *iter;",
      "            assert(MIN_CHAR <= c && c < MIN_CHAR + SIGMA);",
      "",
      "            loc = child_link(loc, c);",
      "            count += data[loc].count_suffixes_in_dict;",
      "        }",
      "",
      "        return count;",
      "    }",
      "};"
    ],
    "description": "trie"
  },
  "suffix_array": {
    "prefix": "suffix_array",
    "body": [
      "// {{{ data_structures/sparse_table.cpp }}}",
      "",
      "#include <vector>",
      "#include <algorithm>",
      "",
      "enum BACKFILL { CYCLIC, NEG_INF, POS_INF };",
      "template<BACKFILL FILL>",
      "struct suffix_array {",
      "    int SZ;",
      "    std::vector<int> input;",
      "    std::vector<int> rank_of;",
      "    std::vector<int> lcp_between_ranks;",
      "    std::vector<int> first_suffix_with_rank;",
      "",
      "    int read_rank(const std::vector<int>& v, int i) const {",
      "        if (i < SZ) {",
      "            return v[i];",
      "        } else switch (FILL) {",
      "            case CYCLIC:  return v[i - SZ];",
      "            case NEG_INF: return -1;",
      "            case POS_INF: return SZ;",
      "        }",
      "    }",
      "",
      "    int rank_of_char  (int i) const { return read_rank(input, i); }",
      "    int rank_of_suffix(int i) const { return read_rank(rank_of, i); }",
      "    int suffix_at_rank(int r) const { return first_suffix_with_rank[r]; }",
      "",
      "    template<typename InputIterator>",
      "    suffix_array(InputIterator begin, InputIterator end) {",
      "        std::vector<int> uniq(begin, end);",
      "        std::sort(uniq.begin(), uniq.end());",
      "        uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());",
      "",
      "        for (InputIterator iter = begin; iter != end; iter = next(iter))",
      "            input.push_back(int((lower_bound(uniq.begin(), uniq.end(), *iter) - uniq.begin())));",
      "",
      "        SZ = int(input.size());",
      "",
      "        rank_of = input;",
      "",
      "        std::vector<int> ct(SZ);",
      "        for (int i = 0; i < SZ; i++) ct[input[i]]++;",
      "        for (int i = 0; i < SZ - 1; i++) ct[i + 1] += ct[i];",
      "",
      "        std::vector<int> by_rank(SZ);",
      "        for (int i = SZ - 1; i >= 0; i--) by_rank[--ct[input[i]]] = i;",
      "",
      "        std::vector<int> new_ranks(SZ);",
      "        std::vector<int> by_rank_updated(SZ);",
      "        for (int len = 1; len < SZ; len *= 2) {",
      "            int tail = 0;",
      "            if (FILL == NEG_INF)",
      "                for (int i = SZ - len; i < SZ; i++)",
      "                    by_rank_updated[tail++] = i;",
      "            for (int rank = 0; rank < SZ; rank++)",
      "                if (by_rank[rank] >= len)",
      "                    by_rank_updated[tail++] = by_rank[rank] - len;",
      "                else if (FILL == CYCLIC)",
      "                    by_rank_updated[tail++] = by_rank[rank] - len + SZ;",
      "            if (FILL == POS_INF)",
      "                for (int i = SZ - len; i < SZ; i++)",
      "                    by_rank_updated[tail++] = i;",
      "            swap(by_rank, by_rank_updated);",
      "",
      "            fill(ct.begin(), ct.end(), 0);",
      "            for (int i = 0; i < SZ; i++) ct[rank_of[i]]++;",
      "            for (int i = 0; i < SZ - 1; i++) ct[i + 1] += ct[i];",
      "",
      "            for (int i = SZ - 1; i >= 0; i--)",
      "                by_rank_updated[--ct[rank_of[by_rank[i]]]] = by_rank[i];",
      "            swap(by_rank, by_rank_updated);",
      "",
      "            std::pair<int, int> prev = { rank_of_suffix(by_rank[0]), rank_of_suffix(by_rank[0] + len) };",
      "            for (int i = 1; i < SZ; i++) {",
      "                std::pair<int, int> cur = { rank_of_suffix(by_rank[i]), rank_of_suffix(by_rank[i] + len) };",
      "                new_ranks[by_rank[i]] = new_ranks[by_rank[i - 1]] + (prev != cur);",
      "                prev = cur;",
      "            }",
      "            swap(rank_of, new_ranks);",
      "        }",
      "",
      "        int R = *max_element(rank_of.begin(), rank_of.end()) + 1;",
      "",
      "        first_suffix_with_rank.resize(R);",
      "        for (int i = SZ - 1; i >= 0; i--)",
      "            first_suffix_with_rank[rank_of_suffix(i)] = i;",
      "",
      "        lcp_between_ranks.resize(SZ - 1);",
      "        for (int i = 0, len = 0; i < SZ; i++) {",
      "            if (rank_of_suffix(i) == R - 1)",
      "                continue;",
      "            int j = suffix_at_rank(rank_of_suffix(i) + 1);",
      "            while (len < SZ && rank_of_char(i + len) == rank_of_char(j + len))",
      "                len++;",
      "            lcp_between_ranks[rank_of_suffix(i)] = len;",
      "            if (len) --len;",
      "        }",
      "    }",
      "",
      "    int longest_common_prefix(int i, int j) const {",
      "        static sparse_table<int>",
      "            lcp_between_ranks_rmq(SZ - 1, std::min<int>, [&](int r) { return lcp_between_ranks[r]; });",
      "",
      "        assert(FILL != CYCLIC && 0 <= i && i < SZ && 0 <= j && j < SZ);",
      "        int ri = rank_of_suffix(i);",
      "        int rj = rank_of_suffix(j);",
      "        if (ri == rj) return FILL == CYCLIC ? SZ : SZ - i;",
      "        if (ri  > rj) std::swap(ri, rj);",
      "        return lcp_between_ranks_rmq.accumulate(ri, rj);",
      "    }",
      "",
      "    std::pair<int, int> ranks_with_prefix(int pos, int len) const {",
      "        assert(0 <= pos && pos + len <= SZ);",
      "        const std::vector<int> &F = first_suffix_with_rank;",
      "        auto less_than = [&](int other_pos, int arg) { return longest_common_prefix(pos, other_pos) < arg; };",
      "        auto geq       = [&](int other_pos, int arg) { return longest_common_prefix(pos, other_pos) >= arg; };",
      "        return std::make_pair(",
      "            lower_bound(F.begin(), F.begin() + rank_of_suffix(pos), len, less_than) - F.begin(),",
      "            lower_bound(F.begin() + rank_of_suffix(pos), F.end(), len, geq) - F.begin()",
      "        );",
      "    }",
      "",
      "    int first_occurrence_of(int pos, int len) const {",
      "        static sparse_table<int>",
      "            by_rank_rmq(SZ, std::min<int>, [&](int r) { return first_suffix_with_rank[r]; });",
      "",
      "        std::pair<int, int> ranks_of_occurrences = ranks_with_prefix(pos, len);",
      "        return by_rank_rmq.accumulate(ranks_of_occurrences.first, ranks_of_occurrences.second);",
      "    }",
      "};"
    ],
    "description": "suffix_array"
  },
  "polynomial_hash": {
    "prefix": "polynomial_hash",
    "body": [
      "// {{{ numeric/modnum.cpp }}}",
      "",
      "#include <vector>",
      "#include <chrono>",
      "#include <random>",
      "#include <array>",
      "#include <cassert>",
      "#include <iostream>",
      "",
      "template<typename x_t, int EvaluationPoints, int AlphabetSize>",
      "struct polynomial_hash {",
      "    static x_t pow(int point, int exponent) {",
      "        static std::vector<x_t> x(EvaluationPoints, 1);",
      "",
      "        if (int(x.size()) == EvaluationPoints) {",
      "            x.push_back(AlphabetSize);",
      "",
      "            std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());",
      "",
      "            for (int i = 1; i < EvaluationPoints; i++)",
      "                x.push_back(AlphabetSize + rng() % std::max(256, AlphabetSize));",
      "        }",
      "",
      "        while (exponent * EvaluationPoints + point >= int(x.size()))",
      "            for (int i = 0; i < EvaluationPoints; i++)",
      "                x.push_back(*(x.end() - EvaluationPoints) * x[EvaluationPoints + i]);",
      "",
      "        return x[exponent * EvaluationPoints + point];",
      "    }",
      "",
      "    int N;",
      "    std::array<x_t, EvaluationPoints> data;",
      "",
      "    polynomial_hash () : N(0) { data.fill(0); }",
      "",
      "    polynomial_hash (x_t v) : N(1) { assert(v.v < AlphabetSize); data.fill(v); }",
      "",
      "    polynomial_hash (int _N, std::array<x_t, EvaluationPoints> _data) : N(_N), data(_data) {}",
      "",
      "    static polynomial_hash concatenate(polynomial_hash a, polynomial_hash b) {",
      "        std::array<x_t, EvaluationPoints> res;",
      "        for (int i = 0; i < EvaluationPoints; i++)",
      "            res[i] = a.data[i] * pow(i, b.N) + b.data[i];",
      "        return { a.N + b.N, res };",
      "    }",
      "",
      "    bool operator == (const polynomial_hash &o) const {",
      "        return N == o.N && data == o.data;",
      "    }",
      "",
      "    bool operator < (const polynomial_hash &o) const {",
      "        return N != o.N ? N < o.N : data < o.data;",
      "    }",
      "",
      "    friend std::ostream& operator << (std::ostream& o, const polynomial_hash& h) {",
      "        o << h.N;",
      "        for (int i = 0; i < EvaluationPoints; i++)",
      "            o << \" \" << h.data[i];",
      "        return o;",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    static std::vector<polynomial_hash> get_prefixes(InputIterator begin, InputIterator end) {",
      "        std::vector<polynomial_hash> res = { polynomial_hash{} };",
      "        for (InputIterator iter = begin; iter != end; iter = next(iter))",
      "            res.push_back(concatenate(res.back(), polynomial_hash(x_t(*iter))));",
      "        return res;",
      "    }",
      "",
      "    static polynomial_hash get_substring(const std::vector<polynomial_hash> &prefixes, int first, int last) {",
      "        std::array<x_t, EvaluationPoints> res;",
      "        for (int i = 0; i < EvaluationPoints; i++)",
      "            res[i] = prefixes[last].data[i] - pow(i, last - first) * prefixes[first].data[i];",
      "        return { last - first, res };",
      "    }",
      "};"
    ],
    "description": "polynomial_hash"
  },
  "mutable_string": {
    "prefix": "mutable_string",
    "body": [
      "// {{{ strings/suffix_automaton.cpp }}}",
      "// {{{ strings/knuth_morris_pratt.cpp }}}",
      "",
      "#include <vector>",
      "#include <cmath>",
      "",
      "template<int MIN_CHAR, int SIGMA>",
      "struct mutable_string {",
      "    int SZ;",
      "    std::vector<int> data;",
      "",
      "    int BLOCK_SZ;",
      "    std::vector<suffix_automaton<MIN_CHAR, SIGMA>> blocks;",
      "",
      "    template<typename InputIterator>",
      "    mutable_string(InputIterator begin, InputIterator end) : data(begin, end) {",
      "        SZ = int(data.size());",
      "        BLOCK_SZ = int(ceil(std::sqrt(data.size())));",
      "        for (int i = 0; i < SZ; i += BLOCK_SZ)",
      "            blocks.emplace_back(data.begin() + i, data.begin() + std::min(i + BLOCK_SZ, SZ));",
      "    }",
      "",
      "    std::vector<int>::iterator block_start(int block_id) {",
      "        return data.begin() + std::min(block_id * BLOCK_SZ, SZ);",
      "    }",
      "    std::vector<int>::const_iterator block_start(int block_id) const {",
      "        return data.begin() + std::min(block_id * BLOCK_SZ, SZ);",
      "    }",
      "",
      "    // O(sqrt(SZ))",
      "    void assign(int i, int c) {",
      "        data[i] = c;",
      "        int block_id = i / BLOCK_SZ;",
      "        blocks[block_id].initialize(block_start(block_id), block_start(block_id + 1));",
      "    }",
      "",
      "    // O(min(|end - begin| * sqrt(SZ), |end - begin| + len))",
      "    template<typename InputIterator>",
      "    int count_matches_in_substring(InputIterator begin, InputIterator end, int L, int R) const {",
      "        static knuth_morris_pratt kmp;",
      "        kmp.initialize(begin, end);",
      "",
      "        int first_block_id = (L + BLOCK_SZ - 1) / BLOCK_SZ;",
      "        int last_block_id  = R / BLOCK_SZ;",
      "",
      "        int expected_work =",
      "            first_block_id * BLOCK_SZ - L",
      "            + (last_block_id - first_block_id) * 3 * kmp.SZ",
      "            + R - last_block_id * BLOCK_SZ;",
      "",
      "        if (first_block_id >= last_block_id || kmp.SZ > BLOCK_SZ || expected_work >= R - L)",
      "            return kmp.count_matches(data.begin() + L, data.begin() + R);",
      "",
      "        int count = 0;",
      "",
      "        count += kmp.count_matches(data.begin() + L, block_start(first_block_id) + kmp.SZ - 1);",
      "",
      "        for (int block_id = first_block_id; block_id < last_block_id; block_id++) {",
      "            count += blocks[block_id].count_occurrences(begin, end);",
      "",
      "            if (block_id != first_block_id) {",
      "                auto boundary = block_start(block_id);",
      "                count += kmp.count_matches(boundary - kmp.SZ + 1, boundary + kmp.SZ - 1);",
      "            }",
      "        }",
      "",
      "        count += kmp.count_matches(block_start(last_block_id) - kmp.SZ + 1, data.begin() + R);",
      "",
      "        return count;",
      "    }",
      "",
      "    template<typename InputIterator>",
      "    int count_matches(InputIterator begin, InputIterator end) const {",
      "        return count_matches_in_substring(begin, end, 0, SZ);",
      "    }",
      "};"
    ],
    "description": "mutable_string"
  }
}