{
  "Max Flow (Dinic's Algorithm)": {
    "prefix": "maxflow",
    "body": [
      "typedef long long ll;",
      "typedef tuple<int, ll, ll> edge;",
      "typedef vector<int> vi;",
      "typedef pair<int, int> ii;",
      "",
      "const ll INF = 1e18;",
      "",
      "class max_flow {",
      "private:",
      "  int V;",
      "  vector<edge> EL;",
      "  vector<vi> AL;",
      "  vi d, last;",
      "  vector<ii> p;",
      "",
      "  bool BFS(int s, int t) {",
      "    d.assign(V, -1); d[s] = 0;",
      "    queue<int> q({s});",
      "    p.assign(V, {-1, -1});",
      "    while (!q.empty()) {",
      "      int u = q.front(); q.pop();",
      "      if (u == t) break;",
      "      for (auto &idx : AL[u]) {",
      "        auto &[v, cap, flow] = EL[idx];",
      "        if ((cap-flow > 0) && (d[v] == -1))",
      "          d[v] = d[u]+1, q.push(v), p[v] = {u, idx};",
      "      }",
      "    }",
      "    return d[t] != -1;",
      "  }",
      "",
      "  ll DFS(int u, int t, ll f = INF) {",
      "    if ((u == t) || (f == 0)) return f;",
      "    for (int &i = last[u]; i < (int)AL[u].size(); ++i) {",
      "      auto &[v, cap, flow] = EL[AL[u][i]];",
      "      if (d[v] != d[u]+1) continue;",
      "      if (ll pushed = DFS(v, t, min(f, cap-flow))) {",
      "        flow += pushed;",
      "        auto &rflow = get<2>(EL[AL[u][i]^1]);",
      "        rflow -= pushed;",
      "        return pushed;",
      "      }",
      "    }",
      "    return 0;",
      "  }",
      "",
      "public:",
      "  max_flow(int initialV) : V(initialV) {",
      "    EL.clear();",
      "    AL.assign(V, vi());",
      "  }",
      "",
      "  void add_edge(int u, int v, ll w, bool directed = true) {",
      "    if (u == v) return;",
      "    EL.emplace_back(v, w, 0);",
      "    AL[u].push_back(EL.size()-1);",
      "    EL.emplace_back(u, directed ? 0 : w, 0);",
      "    AL[v].push_back(EL.size()-1);",
      "  }",
      "",
      "  ll dinic(int s, int t) {",
      "    ll mf = 0;",
      "    while (BFS(s, t)) {",
      "      last.assign(V, 0);",
      "      while (ll f = DFS(s, t))",
      "        mf += f;",
      "    }",
      "    return mf;",
      "  }",
      "};"
    ],
    "description": "Maximum Flow using Dinic's Algorithm (O(V^2*E))",
    "scope": "cpp"
  },

  "Min Cost Max Flow (MCMF)": {
    "prefix": "mcmf",
    "body": [
      "typedef long long ll;",
      "typedef tuple<int, ll, ll, ll> edge;",
      "typedef vector<int> vi;",
      "typedef vector<ll> vll;",
      "",
      "const ll INF = 1e18;",
      "",
      "class min_cost_max_flow {",
      "private:",
      "  int V;",
      "  ll total_cost;",
      "  vector<edge> EL;",
      "  vector<vi> AL;",
      "  vll d;",
      "  vi last, vis;",
      "",
      "  bool SPFA(int s, int t) {",
      "    d.assign(V, INF); d[s] = 0; vis[s] = 1;",
      "    queue<int> q({s});",
      "    while (!q.empty()) {",
      "      int u = q.front(); q.pop(); vis[u] = 0;",
      "      for (auto &idx : AL[u]) {",
      "        auto &[v, cap, flow, cost] = EL[idx];",
      "        if ((cap-flow > 0) && (d[v] > d[u] + cost)) {",
      "          d[v] = d[u]+cost;",
      "          if(!vis[v]) q.push(v), vis[v] = 1;",
      "        }",
      "      }",
      "    }",
      "    return d[t] != INF;",
      "  }",
      "",
      "  ll DFS(int u, int t, ll f = INF) {",
      "    if ((u == t) || (f == 0)) return f;",
      "    vis[u] = 1;",
      "    for (int &i = last[u]; i < (int)AL[u].size(); ++i) {",
      "      auto &[v, cap, flow, cost] = EL[AL[u][i]];",
      "      if (!vis[v] && d[v] == d[u]+cost) {",
      "        if (ll pushed = DFS(v, t, min(f, cap-flow))) {",
      "          total_cost += pushed * cost;",
      "          flow += pushed;",
      "          auto &[rv, rcap, rflow, rcost] = EL[AL[u][i]^1];",
      "          rflow -= pushed;",
      "          vis[u] = 0;",
      "          return pushed;",
      "        }",
      "      }",
      "    }",
      "    vis[u] = 0;",
      "    return 0;",
      "  }",
      "",
      "public:",
      "  min_cost_max_flow(int initialV) : V(initialV), total_cost(0) {",
      "    EL.clear();",
      "    AL.assign(V, vi());",
      "    vis.assign(V, 0);",
      "  }",
      "",
      "  void add_edge(int u, int v, ll w, ll c, bool directed = true) {",
      "    if (u == v) return;",
      "    EL.emplace_back(v, w, 0, c);",
      "    AL[u].push_back(EL.size()-1);",
      "    EL.emplace_back(u, 0, 0, -c);",
      "    AL[v].push_back(EL.size()-1);",
      "    if (!directed) add_edge(v, u, w, c);",
      "  }",
      "",
      "  pair<ll, ll> mcmf(int s, int t) {",
      "    ll mf = 0;",
      "    while (SPFA(s, t)) {",
      "      last.assign(V, 0);",
      "      while (ll f = DFS(s, t))",
      "        mf += f;",
      "    }",
      "    return {mf, total_cost};",
      "  }",
      "};"
    ],
    "description": "Minimum Cost Maximum Flow using SPFA",
    "scope": "cpp"
  },

  "Heavy-Light Decomposition": {
    "prefix": "hld",
    "body": [
      "typedef vector<int> vi;",
      "",
      "vector<vi> AL;",
      "vi par, heavy, group;",
      "",
      "int heavy_light(int x) {",
      "  int size = 1;",
      "  int max_child_size = 0;",
      "  for (auto &y : AL[x]) {",
      "    if (y == par[x]) continue;",
      "    par[y] = x;",
      "    int child_size = heavy_light(y);",
      "    if (child_size > max_child_size) {",
      "      max_child_size = child_size;",
      "      heavy[x] = y;",
      "    }",
      "    size += child_size;",
      "  }",
      "  return size;",
      "}",
      "",
      "void decompose(int x, int p) {",
      "  group[x] = p;",
      "  for (auto &y : AL[x]) {",
      "    if (y == par[x]) continue;",
      "    if (y == heavy[x])",
      "      decompose(y, p);",
      "    else",
      "      decompose(y, y);",
      "  }",
      "}",
      "",
      "void init_hld(int n, int root = 0) {",
      "  par.assign(n, -1);",
      "  heavy.assign(n, -1);",
      "  group.assign(n, -1);",
      "  heavy_light(root);",
      "  decompose(root, root);",
      "}"
    ],
    "description": "Heavy-Light Decomposition for tree path queries",
    "scope": "cpp"
  },

  "Lowest Common Ancestor (LCA)": {
    "prefix": "lca",
    "body": [
      "#define MAX_N 1000",
      "",
      "vector<vector<int>> children;",
      "int L[2*MAX_N], E[2*MAX_N], H[MAX_N], idx;",
      "",
      "void dfs(int cur, int depth) {",
      "  H[cur] = idx;",
      "  E[idx] = cur;",
      "  L[idx++] = depth;",
      "  for (auto &nxt : children[cur]) {",
      "    dfs(nxt, depth+1);",
      "    E[idx] = cur;",
      "    L[idx++] = depth;",
      "  }",
      "}",
      "",
      "void buildRMQ() {",
      "  idx = 0;",
      "  memset(H, -1, sizeof H);",
      "  dfs(0, 0);",
      "}",
      "",
      "// Use with RMQ data structure for O(1) LCA queries"
    ],
    "description": "Lowest Common Ancestor preprocessing with Euler tour",
    "scope": "cpp"
  }
}
