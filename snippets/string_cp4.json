{
  "Trie Data Structure": {
    "prefix": "trie",
    "body": [
      "struct vertex {",
      "  char alphabet;",
      "  bool exist;",
      "  vector<vertex*> child;",
      "  vertex(char a): alphabet(a), exist(false), child(vector<vertex*>(26,nullptr)) {}",
      "};",
      "",
      "class Trie {",
      "private:",
      "  vertex* root;",
      "public:",
      "  Trie() { root = new vertex('!'); }",
      "",
      "  void insert(string word) {",
      "    vertex* cur = root;",
      "    for (int i = 0; i < (int)word.size(); ++i) {",
      "      int alphaNum = word[i]-'A';",
      "      if (cur->child[alphaNum] == NULL)",
      "        cur->child[alphaNum] = new vertex(word[i]);",
      "      cur = cur->child[alphaNum];",
      "    }",
      "    cur->exist = true;",
      "  }",
      "",
      "  bool search(string word) {",
      "    vertex* cur = root;",
      "    for (int i = 0; i < (int)word.size(); ++i) {",
      "      int alphaNum = word[i]-'A';",
      "      if (cur->child[alphaNum] == NULL)",
      "        return false;",
      "      cur = cur->child[alphaNum];",
      "    }",
      "    return cur->exist;",
      "  }",
      "",
      "  bool startsWith(string prefix) {",
      "    vertex* cur = root;",
      "    for (int i = 0; i < (int)prefix.size(); ++i) {",
      "      int alphaNum = prefix[i]-'A';",
      "      if (cur->child[alphaNum] == NULL)",
      "        return false;",
      "      cur = cur->child[alphaNum];",
      "    }",
      "    return true;",
      "  }",
      "};"
    ],
    "description": "Trie data structure for efficient string operations",
    "scope": "cpp"
  },

  "Suffix Array with LCP": {
    "prefix": "suffixarray",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<int> vi;",
      "",
      "class SuffixArray {",
      "private:",
      "  vi RA;",
      "",
      "  void countingSort(int k) {",
      "    int maxi = max(300, n);",
      "    vi c(maxi, 0);",
      "    for (int i = 0; i < n; ++i)",
      "      ++c[i+k < n ? RA[i+k] : 0];",
      "    for (int i = 0, sum = 0; i < maxi; ++i) {",
      "      int t = c[i]; c[i] = sum; sum += t;",
      "    }",
      "    vi tempSA(n);",
      "    for (int i = 0; i < n; ++i)",
      "      tempSA[c[SA[i]+k < n ? RA[SA[i]+k] : 0]++] = SA[i];",
      "    swap(SA, tempSA);",
      "  }",
      "",
      "  void constructSA() {",
      "    SA.resize(n);",
      "    iota(SA.begin(), SA.end(), 0);",
      "    RA.resize(n);",
      "    for (int i = 0; i < n; ++i) RA[i] = T[i];",
      "    for (int k = 1; k < n; k <<= 1) {",
      "      countingSort(k);",
      "      countingSort(0);",
      "      vi tempRA(n);",
      "      int r = 0;",
      "      tempRA[SA[0]] = r;",
      "      for (int i = 1; i < n; ++i)",
      "        tempRA[SA[i]] = ",
      "          ((RA[SA[i]] == RA[SA[i-1]]) && (RA[SA[i]+k] == RA[SA[i-1]+k])) ?",
      "            r : ++r;",
      "      swap(RA, tempRA);",
      "      if (RA[SA[n-1]] == n-1) break;",
      "    }",
      "  }",
      "",
      "  void computeLCP() {",
      "    vi Phi(n);",
      "    vi PLCP(n);",
      "    PLCP.resize(n);",
      "    Phi[SA[0]] = -1;",
      "    for (int i = 1; i < n; ++i)",
      "      Phi[SA[i]] = SA[i-1];",
      "    for (int i = 0, L = 0; i < n; ++i) {",
      "      if (Phi[i] == -1) { PLCP[i] = 0; continue; }",
      "      while ((i+L < n) && (Phi[i]+L < n) && (T[i+L] == T[Phi[i]+L]))",
      "        ++L;",
      "      PLCP[i] = L;",
      "      L = max(L-1, 0);",
      "    }",
      "    LCP.resize(n);",
      "    for (int i = 0; i < n; ++i)",
      "      LCP[i] = PLCP[SA[i]];",
      "  }",
      "",
      "public:",
      "  const char* T;",
      "  const int n;",
      "  vi SA;",
      "  vi LCP;",
      "",
      "  SuffixArray(const char* initialT, const int _n) : T(initialT), n(_n) {",
      "    constructSA();",
      "    computeLCP();",
      "  }",
      "",
      "  ii stringMatching(const char *P) {",
      "    int m = (int)strlen(P);",
      "    int lo = 0, hi = n-1;",
      "    while (lo < hi) {",
      "      int mid = (lo+hi) / 2;",
      "      int res = strncmp(T+SA[mid], P, m);",
      "      (res >= 0) ? hi = mid : lo = mid+1;",
      "    }",
      "    if (strncmp(T+SA[lo], P, m) != 0) return {-1, -1};",
      "    ii ans; ans.first = lo;",
      "    hi = n-1;",
      "    while (lo < hi) {",
      "      int mid = (lo+hi) / 2;",
      "      int res = strncmp(T+SA[mid], P, m);",
      "      (res > 0) ? hi = mid : lo = mid+1;",
      "    }",
      "    if (strncmp(T+SA[hi], P, m) != 0) --hi;",
      "    ans.second = hi;",
      "    return ans;",
      "  }",
      "",
      "  ii LRS() {",
      "    int idx = 0, maxLCP = -1;",
      "    for (int i = 1; i < n; ++i)",
      "      if (LCP[i] > maxLCP)",
      "        maxLCP = LCP[i], idx = i;",
      "    return {maxLCP, idx};",
      "  }",
      "",
      "  ii LCS(int split_idx) {",
      "    int idx = 0, maxLCP = -1;",
      "    for (int i = 1; i < n; ++i) {",
      "      if ((SA[i] < split_idx) == (SA[i-1] < split_idx)) continue;",
      "      if (LCP[i] > maxLCP)",
      "        maxLCP = LCP[i], idx = i;",
      "    }",
      "    return {maxLCP, idx};",
      "  }",
      "};"
    ],
    "description": "Suffix Array with LCP for advanced string operations",
    "scope": "cpp"
  },

  "KMP Algorithm": {
    "prefix": "kmp",
    "body": [
      "int b[${1:MAX_N}];",
      "",
      "void kmpPreprocess(string P) {",
      "    int m = P.length();",
      "    int i = 0, j = -1; b[0] = -1;",
      "    while (i < m) {",
      "        while ((j >= 0) && (P[i] != P[j])) j = b[j];",
      "        ++i; ++j;",
      "        b[i] = j;",
      "    }",
      "}",
      "",
      "int kmpSearch(string T, string P) {",
      "    int n = T.length(), m = P.length();",
      "    int freq = 0;",
      "    int i = 0, j = 0;",
      "    while (i < n) {",
      "        while ((j >= 0) && (T[i] != P[j])) j = b[j];",
      "        ++i; ++j;",
      "        if (j == m) {",
      "            ++freq;",
      "            // Pattern found at index (i-j)",
      "            j = b[j];",
      "        }",
      "    }",
      "    return freq;",
      "}"
    ],
    "description": "Knuth-Morris-Pratt string matching algorithm",
    "scope": "cpp"
  },

  "Rabin-Karp Algorithm": {
    "prefix": "rabinkarp",
    "body": [
      "typedef long long ll;",
      "",
      "const int p = 131;",
      "const int M = 1e9+7;",
      "",
      "int Pow[${1:MAX_N}];",
      "int h[${1:MAX_N}];",
      "",
      "void computeRollingHash(string T) {",
      "    int n = T.length();",
      "    Pow[0] = 1;",
      "    for (int i = 1; i < n; ++i)",
      "        Pow[i] = ((ll)Pow[i-1]*p) % M;",
      "    h[0] = 0;",
      "    for (int i = 0; i < n; ++i) {",
      "        if (i != 0) h[i] = h[i-1];",
      "        h[i] = (h[i] + ((ll)T[i]*Pow[i]) % M) % M;",
      "    }",
      "}",
      "",
      "int modInverse(int b, int m) {",
      "    // Implementation needed - Extended Euclidean Algorithm",
      "    // Returns b^(-1) (mod m)",
      "    ${2:// Add modInverse implementation}",
      "}",
      "",
      "int hash_fast(int L, int R) {",
      "    if (L == 0) return h[R];",
      "    int ans = 0;",
      "    ans = ((h[R] - h[L-1]) % M + M) % M;",
      "    ans = ((ll)ans * modInverse(Pow[L], M)) % M;",
      "    return ans;",
      "}",
      "",
      "int rabinKarpSearch(string T, string P) {",
      "    int n = T.length(), m = P.length();",
      "    computeRollingHash(T);",
      "    ",
      "    int hP = 0;",
      "    for (int i = 0; i < m; ++i)",
      "        hP = (hP + (ll)P[i]*Pow[i]) % M;",
      "    ",
      "    int freq = 0;",
      "    for (int i = 0; i <= n-m; ++i)",
      "        if (hash_fast(i, i+m-1) == hP)",
      "            ++freq;",
      "    return freq;",
      "}"
    ],
    "description": "Rabin-Karp rolling hash string matching algorithm",
    "scope": "cpp"
  },

  "String Alignment (Needleman-Wunsch)": {
    "prefix": "stringalign",
    "body": [
      "int stringAlignment(string A, string B) {",
      "    int n = A.length(), m = B.length();",
      "    vector<vector<int>> table(n+1, vector<int>(m+1, 0));",
      "    ",
      "    // Initialize base cases",
      "    for (int i = 1; i <= n; i++)",
      "        table[i][0] = i * -1; // delete cost",
      "    for (int j = 1; j <= m; j++)",
      "        table[0][j] = j * -1; // insert cost",
      "    ",
      "    // Fill DP table",
      "    for (int i = 1; i <= n; i++) {",
      "        for (int j = 1; j <= m; j++) {",
      "            // Match/mismatch cost",
      "            table[i][j] = table[i-1][j-1] + (A[i-1] == B[j-1] ? 2 : -1);",
      "            // Delete cost",
      "            table[i][j] = max(table[i][j], table[i-1][j] - 1);",
      "            // Insert cost", 
      "            table[i][j] = max(table[i][j], table[i][j-1] - 1);",
      "        }",
      "    }",
      "    ",
      "    return table[n][m];",
      "}"
    ],
    "description": "Needleman-Wunsch algorithm for string alignment",
    "scope": "cpp"
  },

  "Simple Suffix Array (Slow)": {
    "prefix": "suffixarrayslow",
    "body": [
      "vector<int> buildSuffixArray(string T) {",
      "    int n = T.length();",
      "    T += '$'; // Add terminating symbol",
      "    n++;",
      "    ",
      "    vector<int> SA(n);",
      "    iota(SA.begin(), SA.end(), 0);",
      "    ",
      "    // Sort suffixes lexicographically",
      "    sort(SA.begin(), SA.end(), [&](int a, int b) {",
      "        return T.substr(a) < T.substr(b);",
      "    });",
      "    ",
      "    return SA;",
      "}",
      "",
      "vector<int> buildLCP(string T, vector<int>& SA) {",
      "    int n = SA.size();",
      "    vector<int> LCP(n);",
      "    LCP[0] = 0;",
      "    ",
      "    for (int i = 1; i < n; ++i) {",
      "        int L = 0;",
      "        while ((SA[i]+L < n) && (SA[i-1]+L < n) &&",
      "               (T[SA[i]+L] == T[SA[i-1]+L])) ++L;",
      "        LCP[i] = L;",
      "    }",
      "    ",
      "    return LCP;",
      "}"
    ],
    "description": "Simple O(nÂ²log n) suffix array construction for small inputs",
    "scope": "cpp"
  },

  "Naive String Matching": {
    "prefix": "naivematch",
    "body": [
      "int naiveStringMatch(string T, string P) {",
      "    int n = T.length(), m = P.length();",
      "    int freq = 0;",
      "    ",
      "    for (int i = 0; i <= n-m; ++i) {",
      "        bool found = true;",
      "        for (int j = 0; j < m && found; ++j) {",
      "            if (T[i+j] != P[j])",
      "                found = false;",
      "        }",
      "        if (found) {",
      "            ++freq;",
      "            // Pattern found at index i",
      "        }",
      "    }",
      "    return freq;",
      "}"
    ],
    "description": "Naive O(nm) string matching algorithm",
    "scope": "cpp"
  },

  "Rolling Hash": {
    "prefix": "rollinghash",
    "body": [
      "typedef long long ll;",
      "",
      "const int p = 131;",
      "const int MOD = 1e9+7;",
      "",
      "class RollingHash {",
      "private:",
      "    vector<ll> hash, pow;",
      "    int n;",
      "",
      "public:",
      "    RollingHash(string s) {",
      "        n = s.length();",
      "        hash.resize(n+1);",
      "        pow.resize(n+1);",
      "        ",
      "        pow[0] = 1;",
      "        for (int i = 1; i <= n; i++)",
      "            pow[i] = (pow[i-1] * p) % MOD;",
      "        ",
      "        hash[0] = 0;",
      "        for (int i = 0; i < n; i++)",
      "            hash[i+1] = (hash[i] + (s[i] * pow[i]) % MOD) % MOD;",
      "    }",
      "    ",
      "    ll getHash(int l, int r) { // [l, r)",
      "        ll result = (hash[r] - hash[l] + MOD) % MOD;",
      "        result = (result * modInverse(pow[l], MOD)) % MOD;",
      "        return result;",
      "    }",
      "    ",
      "    ll modInverse(ll a, ll m) {",
      "        // Implementation needed",
      "        ${1:// Add modular inverse implementation}",
      "    }",
      "};"
    ],
    "description": "Rolling hash class for efficient substring hashing",
    "scope": "cpp"
  },

  "Extended Euclidean Algorithm": {
    "prefix": "exteuclidean",
    "body": [
      "int extEuclid(int a, int b, int &x, int &y) {",
      "    int xx = y = 0;",
      "    int yy = x = 1;",
      "    while (b) {",
      "        int q = a/b;",
      "        tie(a, b) = make_tuple(b, a%b);",
      "        tie(x, xx) = make_tuple(xx, x-q*xx);",
      "        tie(y, yy) = make_tuple(yy, y-q*yy);",
      "    }",
      "    return a; // returns gcd(a, b)",
      "}",
      "",
      "int modInverse(int b, int m) {",
      "    int x, y;",
      "    int d = extEuclid(b, m, x, y);",
      "    if (d != 1) return -1; // no inverse exists",
      "    return (x + m) % m;",
      "}"
    ],
    "description": "Extended Euclidean algorithm for modular inverse",
    "scope": "cpp"
  },

  "String Algorithms Template": {
    "prefix": "stringtemplate",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "typedef long long ll;",
      "typedef vector<int> vi;",
      "typedef pair<int, int> ii;",
      "",
      "const int MAX_N = ${1:200010};",
      "const int p = 131;",
      "const int MOD = 1e9+7;",
      "",
      "// Add your string algorithms here",
      "",
      "int main() {",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    ",
      "    string T, P;",
      "    cin >> T >> P;",
      "    ",
      "    ${2:// Your string processing code here}",
      "    ",
      "    return 0;",
      "}"
    ],
    "description": "Template for string algorithm problems",
    "scope": "cpp"
  }
}
