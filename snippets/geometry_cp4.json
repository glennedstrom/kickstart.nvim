{
  "Point and Line Structures": {
    "prefix": "geompointline",
    "body": [
      "const double EPS = 1e-9;",
      "",
      "double DEG_to_RAD(double d) { return d*M_PI/180.0; }",
      "double RAD_to_DEG(double r) { return r*180.0/M_PI; }",
      "",
      "struct point_i {",
      "  int x, y;",
      "  point_i() { x = y = 0; }",
      "  point_i(int _x, int _y) : x(_x), y(_y) {}",
      "};",
      "",
      "struct point {",
      "  double x, y;",
      "  point() { x = y = 0.0; }",
      "  point(double _x, double _y) : x(_x), y(_y) {}",
      "  bool operator < (point other) const {",
      "    if (fabs(x-other.x) > EPS)",
      "      return x < other.x;",
      "    return y < other.y;",
      "  }",
      "  bool operator == (point other) const {",
      "    return (fabs(x-other.x) < EPS && (fabs(y-other.y) < EPS));",
      "  }",
      "};",
      "",
      "struct line { double a, b, c; };",
      "",
      "struct vec { double x, y;",
      "  vec(double _x, double _y) : x(_x), y(_y) {}",
      "};"
    ],
    "description": "Basic point, line, and vector structures for computational geometry",
    "scope": "cpp"
  },

  "Basic Geometry Functions": {
    "prefix": "geomfunc",
    "body": [
      "double dist(point p1, point p2) {",
      "  return hypot(p1.x-p2.x, p1.y-p2.y);",
      "}",
      "",
      "point rotate(point p, double theta) {",
      "  double rad = DEG_to_RAD(theta);",
      "  return point(p.x*cos(rad) - p.y*sin(rad),",
      "               p.x*sin(rad) + p.y*cos(rad));",
      "}",
      "",
      "vec toVec(const point &a, const point &b) {",
      "  return vec(b.x-a.x, b.y-a.y);",
      "}",
      "",
      "vec scale(const vec &v, double s) {",
      "  return vec(v.x*s, v.y*s);",
      "}",
      "",
      "point translate(const point &p, const vec &v) {",
      "  return point(p.x+v.x, p.y+v.y);",
      "}",
      "",
      "double dot(vec a, vec b) { return (a.x*b.x + a.y*b.y); }",
      "",
      "double cross(vec a, vec b) { return a.x*b.y - a.y*b.x; }",
      "",
      "double norm_sq(vec v) { return v.x*v.x + v.y*v.y; }"
    ],
    "description": "Essential geometry functions for distance, rotation, vectors, and operations",
    "scope": "cpp"
  },

  "Line Operations": {
    "prefix": "geomlineops",
    "body": [
      "void pointsToLine(point p1, point p2, line &l) {",
      "  if (fabs(p1.x-p2.x) < EPS)",
      "    l = {1.0, 0.0, -p1.x};",
      "  else {",
      "    double a = -(double)(p1.y-p2.y) / (p1.x-p2.x);",
      "    l = {a, 1.0, -(double)(a*p1.x) - p1.y};",
      "  }",
      "}",
      "",
      "bool areParallel(line l1, line l2) {",
      "  return (fabs(l1.a-l2.a) < EPS) && (fabs(l1.b-l2.b) < EPS);",
      "}",
      "",
      "bool areSame(line l1, line l2) {",
      "  return areParallel(l1 ,l2) && (fabs(l1.c-l2.c) < EPS);",
      "}",
      "",
      "bool areIntersect(line l1, line l2, point &p) {",
      "  if (areParallel(l1, l2)) return false;",
      "  p.x = (l2.b*l1.c - l1.b*l2.c) / (l2.a*l1.b - l1.a*l2.b);",
      "  if (fabs(l1.b) > EPS) p.y = -(l1.a*p.x + l1.c);",
      "  else                  p.y = -(l2.a*p.x + l2.c);",
      "  return true;",
      "}",
      "",
      "double distToLine(point p, point a, point b, point &c) {",
      "  vec ap = toVec(a, p), ab = toVec(a, b);",
      "  double u = dot(ap, ab) / norm_sq(ab);",
      "  c = translate(a, scale(ab, u));",
      "  return dist(p, c);",
      "}",
      "",
      "double distToLineSegment(point p, point a, point b, point &c) {",
      "  vec ap = toVec(a, p), ab = toVec(a, b);",
      "  double u = dot(ap, ab) / norm_sq(ab);",
      "  if (u < 0.0) {",
      "    c = point(a.x, a.y);",
      "    return dist(p, a);",
      "  }",
      "  if (u > 1.0) {",
      "    c = point(b.x, b.y);",
      "    return dist(p, b);",
      "  }",
      "  return distToLine(p, a, b, c);",
      "}"
    ],
    "description": "Line operations including intersection, distance calculations, and parallel checks",
    "scope": "cpp"
  },

  "CCW and Collinear Tests": {
    "prefix": "geomccwtest",
    "body": [
      "bool ccw(point p, point q, point r) {",
      "  return cross(toVec(p, q), toVec(p, r)) > -EPS;",
      "}",
      "",
      "bool collinear(point p, point q, point r) {",
      "  return fabs(cross(toVec(p, q), toVec(p, r))) < EPS;",
      "}",
      "",
      "double angle(const point &a, const point &o, const point &b) {",
      "  vec oa = toVec(o, a), ob = toVec(o, b);",
      "  return acos(dot(oa, ob) / sqrt(norm_sq(oa) * norm_sq(ob)));",
      "}"
    ],
    "description": "Counter-clockwise test, collinearity check, and angle calculation",
    "scope": "cpp"
  },

  "Polygon Operations": {
    "prefix": "geompolygon",
    "body": [
      "double perimeter(const vector<point> &P) {",
      "  double ans = 0.0;",
      "  for (int i = 0; i < (int)P.size()-1; ++i)",
      "    ans += dist(P[i], P[i+1]);",
      "  return ans;",
      "}",
      "",
      "double area(const vector<point> &P) {",
      "  double ans = 0.0;",
      "  for (int i = 0; i < (int)P.size()-1; ++i)",
      "    ans += (P[i].x*P[i+1].y - P[i+1].x*P[i].y);",
      "  return fabs(ans)/2.0;",
      "}",
      "",
      "bool isConvex(const vector<point> &P) {",
      "  int n = (int)P.size();",
      "  if (n <= 3) return false;",
      "  bool firstTurn = ccw(P[0], P[1], P[2]);",
      "  for (int i = 1; i < n-1; ++i)",
      "    if (ccw(P[i], P[i+1], P[(i+2) == n ? 1 : i+2]) != firstTurn)",
      "      return false;",
      "  return true;",
      "}",
      "",
      "int insidePolygon(point pt, const vector<point> &P) {",
      "  int n = (int)P.size();",
      "  if (n <= 3) return -1;",
      "  bool on_polygon = false;",
      "  for (int i = 0; i < n-1; ++i)",
      "    if (fabs(dist(P[i], pt) + dist(pt, P[i+1]) - dist(P[i], P[i+1])) < EPS)",
      "      on_polygon = true;",
      "  if (on_polygon) return 0;",
      "  double sum = 0.0;",
      "  for (int i = 0; i < n-1; ++i) {",
      "    if (ccw(pt, P[i], P[i+1]))",
      "      sum += angle(P[i], pt, P[i+1]);",
      "    else",
      "      sum -= angle(P[i], pt, P[i+1]);",
      "  }",
      "  return fabs(sum) > M_PI ? 1 : -1;",
      "}"
    ],
    "description": "Polygon operations: perimeter, area, convexity test, and point-in-polygon test",
    "scope": "cpp"
  },

  "Convex Hull Graham": {
    "prefix": "geomconvexhull",
    "body": [
      "vector<point> CH_Graham(vector<point> &Pts) {",
      "  vector<point> P(Pts);",
      "  int n = (int)P.size();",
      "  if (n <= 3) {",
      "    if (!(P[0] == P[n-1])) P.push_back(P[0]);",
      "    return P;",
      "  }",
      "",
      "  int P0 = min_element(P.begin(), P.end())-P.begin();",
      "  swap(P[0], P[P0]);",
      "",
      "  sort(++P.begin(), P.end(), [&](point a, point b) {",
      "    return ccw(P[0], a, b);",
      "  });",
      "",
      "  vector<point> S({P[n-1], P[0], P[1]});",
      "  int i = 2;",
      "  while (i < n) {",
      "    int j = (int)S.size()-1;",
      "    if (ccw(S[j-1], S[j], P[i]))",
      "      S.push_back(P[i++]);",
      "    else",
      "      S.pop_back();",
      "  }",
      "  return S;",
      "}"
    ],
    "description": "Graham's scan algorithm for convex hull (O(n log n))",
    "scope": "cpp"
  },

  "Circle Operations": {
    "prefix": "geomcircle",
    "body": [
      "int insideCircle(point_i p, point_i c, int r) {",
      "  int dx = p.x-c.x, dy = p.y-c.y;",
      "  int Euc = dx*dx + dy*dy, rSq = r*r;",
      "  return Euc < rSq ? 1 : Euc == rSq ? 0 : -1;",
      "}",
      "",
      "bool circle2PtsRad(point p1, point p2, double r, point &c) {",
      "  double d2 = (p1.x-p2.x) * (p1.x-p2.x) + ",
      "              (p1.y-p2.y) * (p1.y-p2.y);",
      "  double det = r*r / d2 - 0.25;",
      "  if (det < 0.0) return false;",
      "  double h = sqrt(det);",
      "  c.x = (p1.x+p2.x) * 0.5 + (p1.y-p2.y) * h;",
      "  c.y = (p1.y+p2.y) * 0.5 + (p2.x-p1.x) * h;",
      "  return true;",
      "}"
    ],
    "description": "Circle operations: point-in-circle test and circle from 2 points and radius",
    "scope": "cpp"
  },

  "Triangle Operations": {
    "prefix": "geomtriangle",
    "body": [
      "double perimeter(double ab, double bc, double ca) {",
      "  return ab + bc + ca;",
      "}",
      "",
      "double area(double ab, double bc, double ca) {",
      "  double s = 0.5 * perimeter(ab, bc, ca);",
      "  return sqrt(s) * sqrt(s-ab) * sqrt(s-bc) * sqrt(s-ca);",
      "}",
      "",
      "double rInCircle(double ab, double bc, double ca) {",
      "  return area(ab, bc, ca) / (0.5 * perimeter(ab, bc, ca));",
      "}",
      "",
      "double rCircumCircle(double ab, double bc, double ca) {",
      "  return ab * bc * ca / (4.0 * area(ab, bc, ca));",
      "}",
      "",
      "int circumCircle(point p1, point p2, point p3, point &ctr, double &r){",
      "  double a = p2.x - p1.x, b = p2.y - p1.y;",
      "  double c = p3.x - p1.x, d = p3.y - p1.y;",
      "  double e = a * (p1.x + p2.x) + b * (p1.y + p2.y);",
      "  double f = c * (p1.x + p3.x) + d * (p1.y + p3.y);",
      "  double g = 2.0 * (a * (p3.y - p2.y) - b * (p3.x - p2.x));",
      "  if (fabs(g) < EPS) return 0;",
      "",
      "  ctr.x = (d*e - b*f) / g;",
      "  ctr.y = (a*f - c*e) / g;",
      "  r = dist(p1, ctr);",
      "  return 1;",
      "}",
      "",
      "bool canFormTriangle(double a, double b, double c) {",
      "  return (a+b > c) && (a+c > b) && (b+c > a);",
      "}"
    ],
    "description": "Triangle operations: area, perimeter, incircle, circumcircle, and triangle inequality",
    "scope": "cpp"
  },

  "Polygon Cutting": {
    "prefix": "geomcutpolygon",
    "body": [
      "point lineIntersectSeg(point p, point q, point A, point B) {",
      "  double a = B.y-A.y, b = A.x-B.x, c = B.x*A.y - A.x*B.y;",
      "  double u = fabs(a*p.x + b*p.y + c);",
      "  double v = fabs(a*q.x + b*q.y + c);",
      "  return point((p.x*v + q.x*u) / (u+v), (p.y*v + q.y*u) / (u+v));",
      "}",
      "",
      "vector<point> cutPolygon(point A, point B, const vector<point> &Q) {",
      "  vector<point> P;",
      "  for (int i = 0; i < (int)Q.size(); ++i) {",
      "    double left1 = cross(toVec(A, B), toVec(A, Q[i])), left2 = 0;",
      "    if (i != (int)Q.size()-1) left2 = cross(toVec(A, B), toVec(A, Q[i+1]));",
      "    if (left1 > -EPS) P.push_back(Q[i]);",
      "    if (left1*left2 < -EPS)",
      "      P.push_back(lineIntersectSeg(Q[i], Q[i+1], A, B));",
      "  }",
      "  if (!P.empty() && !(P.back() == P.front()))",
      "    P.push_back(P.front());",
      "  return P;",
      "}"
    ],
    "description": "Sutherland-Hodgman polygon clipping algorithm",
    "scope": "cpp"
  }
}
