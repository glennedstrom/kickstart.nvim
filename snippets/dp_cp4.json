{
  "Longest Increasing Subsequence (LIS) O(n^2)": {
    "prefix": "lis",
    "body": [
      "typedef vector<int> vi;",
      "",
      "vi A;",
      "vi p; // predecessor array",
      "int memo[10010];",
      "",
      "void print_LIS(int i) {",
      "  if (p[i] == -1) { printf(\"%d\", A[i]); return; }",
      "  print_LIS(p[i]);",
      "  printf(\" %d\", A[i]);",
      "}",
      "",
      "int LIS(int i) {",
      "  if (i == 0) return 1;",
      "  int &ans = memo[i];",
      "  if (ans != -1) return ans;",
      "  ans = 1;",
      "  for (int j = 0; j < i; ++j)",
      "    if (A[j] < A[i])",
      "      ans = max(ans, LIS(j)+1);",
      "  return ans;",
      "}"
    ],
    "description": "Longest Increasing Subsequence using O(n^2) dynamic programming with memoization",
    "scope": "cpp"
  },

  "Longest Increasing Subsequence (LIS) O(n log k)": {
    "prefix": "lisfast",
    "body": [
      "typedef vector<int> vi;",
      "",
      "vi A;",
      "vi p; // predecessor array",
      "",
      "void print_LIS(int i) {",
      "  if (p[i] == -1) { printf(\"%d\", A[i]); return; }",
      "  print_LIS(p[i]);",
      "  printf(\" %d\", A[i]);",
      "}",
      "",
      "int LIS_fast(int n) {",
      "  int k = 0, lis_end = 0;",
      "  vi L(n, 0), L_id(n, 0);",
      "  p.assign(n, -1);",
      "",
      "  for (int i = 0; i < n; ++i) {",
      "    int pos = lower_bound(L.begin(), L.begin()+k, A[i]) - L.begin();",
      "    L[pos] = A[i];",
      "    L_id[pos] = i;",
      "    p[i] = pos ? L_id[pos-1] : -1;",
      "    if (pos == k) {",
      "      k = pos+1;",
      "      lis_end = i;",
      "    }",
      "  }",
      "  ",
      "  // To print the LIS: print_LIS(lis_end);",
      "  return k;",
      "}"
    ],
    "description": "Fast Longest Increasing Subsequence using O(n log k) algorithm with binary search",
    "scope": "cpp"
  },

  "Maximum 1D Range Sum (Kadane's Algorithm)": {
    "prefix": "kadane",
    "body": [
      "int maxRangeSum(vector<int>& A) {",
      "  int n = A.size();",
      "  int sum = 0, ans = 0;",
      "  for (int i = 0; i < n; ++i) {",
      "    sum += A[i];",
      "    ans = max(ans, sum);",
      "    if (sum < 0) sum = 0;",
      "  }",
      "  return ans;",
      "}",
      "",
      "// Alternative with indices",
      "int maxRangeSum(int A[], int n, int &start, int &end) {",
      "  int sum = 0, ans = 0;",
      "  start = end = 0;",
      "  int temp_start = 0;",
      "  for (int i = 0; i < n; ++i) {",
      "    sum += A[i];",
      "    if (sum > ans) {",
      "      ans = sum;",
      "      start = temp_start;",
      "      end = i;",
      "    }",
      "    if (sum < 0) {",
      "      sum = 0;",
      "      temp_start = i + 1;",
      "    }",
      "  }",
      "  return ans;",
      "}"
    ],
    "description": "Kadane's algorithm for maximum subarray sum in O(n) time",
    "scope": "cpp"
  },

  "Classic DP Template": {
    "prefix": "dptemplate",
    "body": [
      "// Top-down DP with memoization",
      "int memo[${1:1005}][${2:1005}];",
      "",
      "int dp(int ${3:i}, int ${4:j}) {",
      "  // Base cases",
      "  if (${5:base_condition}) return ${6:base_value};",
      "  ",
      "  // Check memo",
      "  int &ans = memo[${3:i}][${4:j}];",
      "  if (ans != -1) return ans;",
      "  ",
      "  // Recursive cases",
      "  ans = ${7:initial_value};",
      "  ${8:// Add transitions here}",
      "  ",
      "  return ans;",
      "}",
      "",
      "// Bottom-up DP",
      "int dp_bu(int n, int m) {",
      "  vector<vector<int>> dp(n+1, vector<int>(m+1, 0));",
      "  ",
      "  // Initialize base cases",
      "  ${9:// Initialize here}",
      "  ",
      "  // Fill the table",
      "  for (int i = ${10:1}; i <= n; i++) {",
      "    for (int j = ${11:1}; j <= m; j++) {",
      "      ${12:// Add transitions here}",
      "    }",
      "  }",
      "  ",
      "  return dp[n][m];",
      "}"
    ],
    "description": "Template for both top-down and bottom-up dynamic programming",
    "scope": "cpp"
  },

  "0/1 Knapsack": {
    "prefix": "knapsack",
    "body": [
      "int memo[${1:1005}][${2:1005}];",
      "vector<int> weight, value;",
      "",
      "int knapsack(int i, int W) {",
      "  if (i < 0 || W == 0) return 0;",
      "  ",
      "  int &ans = memo[i][W];",
      "  if (ans != -1) return ans;",
      "  ",
      "  ans = knapsack(i-1, W); // don't take item i",
      "  if (weight[i] <= W)",
      "    ans = max(ans, knapsack(i-1, W-weight[i]) + value[i]);",
      "  ",
      "  return ans;",
      "}",
      "",
      "// Bottom-up version",
      "int knapsack_bu(int n, int W) {",
      "  vector<vector<int>> dp(n+1, vector<int>(W+1, 0));",
      "  ",
      "  for (int i = 1; i <= n; i++) {",
      "    for (int w = 1; w <= W; w++) {",
      "      dp[i][w] = dp[i-1][w]; // don't take",
      "      if (weight[i-1] <= w)",
      "        dp[i][w] = max(dp[i][w], dp[i-1][w-weight[i-1]] + value[i-1]);",
      "    }",
      "  }",
      "  ",
      "  return dp[n][W];",
      "}"
    ],
    "description": "0/1 Knapsack problem using dynamic programming",
    "scope": "cpp"
  },

  "Coin Change (Min Coins)": {
    "prefix": "coinchange",
    "body": [
      "const int INF = 1e9;",
      "int memo[${1:10005}];",
      "vector<int> coins;",
      "",
      "int coinChange(int amount) {",
      "  if (amount == 0) return 0;",
      "  if (amount < 0) return INF;",
      "  ",
      "  int &ans = memo[amount];",
      "  if (ans != -1) return ans;",
      "  ",
      "  ans = INF;",
      "  for (int coin : coins) {",
      "    ans = min(ans, coinChange(amount - coin) + 1);",
      "  }",
      "  ",
      "  return ans;",
      "}",
      "",
      "// Bottom-up version",
      "int coinChange_bu(int amount) {",
      "  vector<int> dp(amount + 1, INF);",
      "  dp[0] = 0;",
      "  ",
      "  for (int i = 1; i <= amount; i++) {",
      "    for (int coin : coins) {",
      "      if (i >= coin)",
      "        dp[i] = min(dp[i], dp[i - coin] + 1);",
      "    }",
      "  }",
      "  ",
      "  return dp[amount] == INF ? -1 : dp[amount];",
      "}"
    ],
    "description": "Coin change problem - minimum number of coins to make amount",
    "scope": "cpp"
  },

  "Edit Distance (Levenshtein)": {
    "prefix": "editdistance",
    "body": [
      "int memo[${1:1005}][${2:1005}];",
      "string s1, s2;",
      "",
      "int editDistance(int i, int j) {",
      "  if (i == 0) return j; // insert all chars of s2",
      "  if (j == 0) return i; // delete all chars of s1",
      "  ",
      "  int &ans = memo[i][j];",
      "  if (ans != -1) return ans;",
      "  ",
      "  if (s1[i-1] == s2[j-1])",
      "    ans = editDistance(i-1, j-1); // no operation needed",
      "  else",
      "    ans = 1 + min({editDistance(i-1, j),     // delete",
      "                   editDistance(i, j-1),     // insert",
      "                   editDistance(i-1, j-1)}); // replace",
      "  ",
      "  return ans;",
      "}",
      "",
      "// Bottom-up version",
      "int editDistance_bu(string s1, string s2) {",
      "  int m = s1.length(), n = s2.length();",
      "  vector<vector<int>> dp(m+1, vector<int>(n+1));",
      "  ",
      "  for (int i = 0; i <= m; i++) dp[i][0] = i;",
      "  for (int j = 0; j <= n; j++) dp[0][j] = j;",
      "  ",
      "  for (int i = 1; i <= m; i++) {",
      "    for (int j = 1; j <= n; j++) {",
      "      if (s1[i-1] == s2[j-1])",
      "        dp[i][j] = dp[i-1][j-1];",
      "      else",
      "        dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});",
      "    }",
      "  }",
      "  ",
      "  return dp[m][n];",
      "}"
    ],
    "description": "Edit distance (Levenshtein distance) using dynamic programming",
    "scope": "cpp"
  },

  "Longest Common Subsequence (LCS)": {
    "prefix": "lcs",
    "body": [
      "int memo[${1:1005}][${2:1005}];",
      "string s1, s2;",
      "",
      "int lcs(int i, int j) {",
      "  if (i == 0 || j == 0) return 0;",
      "  ",
      "  int &ans = memo[i][j];",
      "  if (ans != -1) return ans;",
      "  ",
      "  if (s1[i-1] == s2[j-1])",
      "    ans = 1 + lcs(i-1, j-1);",
      "  else",
      "    ans = max(lcs(i-1, j), lcs(i, j-1));",
      "  ",
      "  return ans;",
      "}",
      "",
      "// Bottom-up version",
      "int lcs_bu(string s1, string s2) {",
      "  int m = s1.length(), n = s2.length();",
      "  vector<vector<int>> dp(m+1, vector<int>(n+1, 0));",
      "  ",
      "  for (int i = 1; i <= m; i++) {",
      "    for (int j = 1; j <= n; j++) {",
      "      if (s1[i-1] == s2[j-1])",
      "        dp[i][j] = 1 + dp[i-1][j-1];",
      "      else",
      "        dp[i][j] = max(dp[i-1][j], dp[i][j-1]);",
      "    }",
      "  }",
      "  ",
      "  return dp[m][n];",
      "}"
    ],
    "description": "Longest Common Subsequence using dynamic programming",
    "scope": "cpp"
  }
}
