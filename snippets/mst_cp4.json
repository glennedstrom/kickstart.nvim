{
  "Kruskal MST": {
    "prefix": "kruskal",
    "body": [
      "typedef tuple<int, int, int> iii;",
      "typedef vector<int> vi;",
      "",
      "class UnionFind {",
      "private:",
      "  vi p, rank, setSize;",
      "  int numSets;",
      "public:",
      "  UnionFind(int N) {",
      "    p.assign(N, 0); for (int i = 0; i < N; ++i) p[i] = i;",
      "    rank.assign(N, 0);",
      "    setSize.assign(N, 1);",
      "    numSets = N;",
      "  }",
      "  int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }",
      "  bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }",
      "  void unionSet(int i, int j) {",
      "    if (isSameSet(i, j)) return;",
      "    int x = findSet(i), y = findSet(j);",
      "    if (rank[x] > rank[y]) swap(x, y);",
      "    p[x] = y;",
      "    if (rank[x] == rank[y]) ++rank[y];",
      "    setSize[y] += setSize[x];",
      "    --numSets;",
      "  }",
      "  int numDisjointSets() { return numSets; }",
      "  int sizeOfSet(int i) { return setSize[findSet(i)]; }",
      "};",
      "",
      "int kruskal(int V, vector<iii>& edges) {",
      "  sort(edges.begin(), edges.end());",
      "  int mst_cost = 0, num_taken = 0;",
      "  UnionFind UF(V);",
      "  for (auto [w, u, v] : edges) {",
      "    if (UF.isSameSet(u, v)) continue;",
      "    mst_cost += w;",
      "    UF.unionSet(u, v);",
      "    ++num_taken;",
      "    if (num_taken == V-1) break;",
      "  }",
      "  return mst_cost;",
      "}"
    ],
    "description": "Kruskal's algorithm for Minimum Spanning Tree using Union-Find (O(E log E))",
    "scope": "cpp"
  },

  "Prim MST": {
    "prefix": "prim",
    "body": [
      "typedef pair<int, int> ii;",
      "typedef vector<int> vi;",
      "typedef vector<ii> vii;",
      "",
      "vector<vii> AL;",
      "vi taken;",
      "priority_queue<ii> pq;",
      "",
      "void process(int u) {",
      "  taken[u] = 1;",
      "  for (auto &[v, w] : AL[u])",
      "    if (!taken[v])",
      "      pq.push({-w, -v});",
      "}",
      "",
      "int prim(int V, int start = 0) {",
      "  taken.assign(V, 0);",
      "  process(start);",
      "  int mst_cost = 0, num_taken = 0;",
      "  while (!pq.empty()) {",
      "    auto [w, u] = pq.top(); pq.pop();",
      "    w = -w; u = -u;",
      "    if (taken[u]) continue;",
      "    mst_cost += w;",
      "    process(u);",
      "    ++num_taken;",
      "    if (num_taken == V-1) break;",
      "  }",
      "  return mst_cost;",
      "}"
    ],
    "description": "Prim's algorithm for Minimum Spanning Tree using priority queue (O(E log V))",
    "scope": "cpp"
  }
}
