{
  "Modular Arithmetic": {
    "prefix": "euclid",
    "body": [
      "typedef long long ll;",
      "",
      "ll mod(ll a, int m) {",
      "  return ((a%m) + m) % m;",
      "}",
      "",
      "ll modPow(ll b, int p, int m) {",
      "  if (p == 0) return 1;",
      "  ll ans = modPow(b, p/2, m);",
      "  ans = mod(ans*ans, m);",
      "  if (p&1) ans = mod(ans*b, m);",
      "  return ans;",
      "}",
      "",
      "int extEuclid(int a, int b, int &x, int &y) {",
      "  int xx = y = 0;",
      "  int yy = x = 1;",
      "  while (b) {",
      "    int q = a/b;",
      "    tie(a, b) = tuple(b, a%b);",
      "    tie(x, xx) = tuple(xx, x-q*xx);",
      "    tie(y, yy) = tuple(yy, y-q*yy);",
      "  }",
      "  return a;",
      "}",
      "",
      "int modInverse(int b, int m) {",
      "  int x, y;",
      "  int d = extEuclid(b, m, x, y);",
      "  if (d != 1) return -1;",
      "  return mod(x, m);",
      "}"
    ],
    "description": "Modular arithmetic operations: modPow, extended Euclidean, modular inverse",
    "scope": "cpp"
  },

  "Sieve of Eratosthenes: Generate Primes": {
    "prefix": "primes",
    "body": [
      "typedef long long ll;",
      "typedef vector<ll> vll;",
      "",
      "ll _sieve_size;",
      "bitset<10000010> bs;",
      "vll p;",
      "",
      "// TODO: call sieve in the main method",
      "void sieve(ll upperbound) {",
      "  _sieve_size = upperbound+1;",
      "  bs.set();",
      "  bs[0] = bs[1] = 0;",
      "  for (ll i = 2; i < _sieve_size; ++i) if (bs[i]) {",
      "    for (ll j = i*i; j < _sieve_size; j += i) bs[j] = 0;",
      "    p.push_back(i);",
      "  }",
      "}",
      "",
      "bool isPrime(ll N) {",
      "  if (N < _sieve_size) return bs[N];",
      "  for (int i = 0; i < (int)p.size() && p[i]*p[i] <= N; ++i)",
      "    if (N%p[i] == 0)",
      "      return false;",
      "  return true;",
      "}"
    ],
    "description": "Sieve of Eratosthenes for prime generation and primality testing",
    "scope": "cpp"
  },

  "Prime Factorization": {
    "prefix": "primefactor",
    "body": [
      "vll primeFactors(ll N) {",
      "  vll factors;",
      "  for (int i = 0; i < (int)p.size() && p[i]*p[i] <= N; ++i)",
      "    while (N%p[i] == 0) {",
      "      N /= p[i];",
      "      factors.push_back(p[i]);",
      "    }",
      "  if (N != 1) factors.push_back(N);",
      "  return factors;",
      "}",
      "",
      "int numPF(ll N) {",
      "  int ans = 0;",
      "  for (int i = 0; i < (int)p.size() && p[i]*p[i] <= N; ++i)",
      "    while (N%p[i] == 0) { N /= p[i]; ++ans; }",
      "  return ans + (N != 1);",
      "}",
      "",
      "int numDiffPF(ll N) {",
      "  int ans = 0;",
      "  for (int i = 0; i < p.size() && p[i]*p[i] <= N; ++i) {",
      "    if (N%p[i] == 0) ++ans;",
      "    while (N%p[i] == 0) N /= p[i];",
      "  }",
      "  if (N != 1) ++ans;",
      "  return ans;",
      "}",
      "",
      "ll sumPF(ll N) {",
      "  ll ans = 0;",
      "  for (int i = 0; i < p.size() && p[i]*p[i] <= N; ++i)",
      "    while (N%p[i] == 0) { N /= p[i]; ans += p[i]; }",
      "  if (N != 1) ans += N;",
      "  return ans;",
      "}"
    ],
    "description": "Prime factorization and related functions (count, sum of prime factors)",
    "scope": "cpp"
  },

  "Divisor Functions": {
    "prefix": "divisor",
    "body": [
      "int numDiv(ll N) {",
      "  int ans = 1;",
      "  for (int i = 0; i < (int)p.size() && p[i]*p[i] <= N; ++i) {",
      "    int power = 0;",
      "    while (N%p[i] == 0) { N /= p[i]; ++power; }",
      "    ans *= power+1;",
      "  }",
      "  return (N != 1) ? 2*ans : ans;",
      "}",
      "",
      "ll sumDiv(ll N) {",
      "  ll ans = 1;",
      "  for (int i = 0; i < (int)p.size() && p[i]*p[i] <= N; ++i) {",
      "    ll multiplier = p[i], total = 1;",
      "    while (N%p[i] == 0) {",
      "      N /= p[i];",
      "      total += multiplier;",
      "      multiplier *= p[i];",
      "    }",
      "    ans *= total;",
      "  }",
      "  if (N != 1) ans *= (N+1);",
      "  return ans;",
      "}",
      "",
      "ll EulerPhi(ll N) {",
      "  ll ans = N;",
      "  for (int i = 0; i < (int)p.size() && p[i]*p[i] <= N; ++i) {",
      "    if (N%p[i] == 0) ans -= ans/p[i];",
      "    while (N%p[i] == 0) N /= p[i];",
      "  }",
      "  if (N != 1) ans -= ans/N;",
      "  return ans;",
      "}"
    ],
    "description": "Divisor functions: count divisors, sum of divisors, Euler's totient function",
    "scope": "cpp"
  },

  "Combinatorics with Modular Arithmetic": {
    "prefix": "combinatorics",
    "body": [
      "typedef long long ll;",
      "",
      "const int MAX_N = 100010;",
      "const int p = 1e9+7;",
      "",
      "ll fact[MAX_N];",
      "",
      "ll modPow(ll b, int p, int m) {",
      "  if (p == 0) return 1;",
      "  ll ans = modPow(b, p/2, m);",
      "  ans = (ans*ans) % m;",
      "  if (p&1) ans = (ans*b) % m;",
      "  return ans;",
      "}",
      "",
      "ll inv(ll a) {",
      "  return modPow(a, p-2, p);",
      "}",
      "",
      "void precomputeFactorials() {",
      "  fact[0] = 1;",
      "  for (int i = 1; i < MAX_N; ++i)",
      "    fact[i] = (fact[i-1]*i) % p;",
      "}",
      "",
      "ll C(int n, int k) {",
      "  if (n < k) return 0;",
      "  return (((fact[n] * inv(fact[k])) % p) * inv(fact[n-k])) % p;",
      "}",
      "",
      "ll fibonacci(int n) {",
      "  if (n <= 1) return n;",
      "  ll a = 0, b = 1;",
      "  for (int i = 2; i <= n; i++) {",
      "    ll c = (a + b) % p;",
      "    a = b;",
      "    b = c;",
      "  }",
      "  return b;",
      "}",
      "",
      "ll catalan(int n) {",
      "  if (n <= 1) return 1;",
      "  return (((4*n-2) % p) * catalan(n-1) % p * inv(n+1)) % p;",
      "}"
    ],
    "description": "Combinatorics: factorial, binomial coefficients, Fibonacci, Catalan numbers with modular arithmetic",
    "scope": "cpp"
  },

  "Fast Fibonacci Matrix": {
    "prefix": "fibmatrix",
    "body": [
      "typedef long long ll;",
      "typedef vector<vector<ll>> matrix;",
      "",
      "const int MOD = 1e9+7;",
      "",
      "matrix multiply(matrix A, matrix B) {",
      "  int n = A.size();",
      "  matrix C(n, vector<ll>(n, 0));",
      "  for (int i = 0; i < n; i++)",
      "    for (int j = 0; j < n; j++)",
      "      for (int k = 0; k < n; k++)",
      "        C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;",
      "  return C;",
      "}",
      "",
      "matrix matrixPower(matrix base, ll exp) {",
      "  int n = base.size();",
      "  matrix result(n, vector<ll>(n, 0));",
      "  for (int i = 0; i < n; i++) result[i][i] = 1;",
      "  ",
      "  while (exp > 0) {",
      "    if (exp & 1) result = multiply(result, base);",
      "    base = multiply(base, base);",
      "    exp >>= 1;",
      "  }",
      "  return result;",
      "}",
      "",
      "ll fibonacciMatrix(ll n) {",
      "  if (n <= 1) return n;",
      "  matrix base = {{1, 1}, {1, 0}};",
      "  matrix result = matrixPower(base, n-1);",
      "  return result[0][0];",
      "}"
    ],
    "description": "Fast Fibonacci computation using matrix exponentiation (O(log n))",
    "scope": "cpp"
  }
}
